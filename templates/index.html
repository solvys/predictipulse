{% extends "base.html" %}

{% block content %}
<div class="app-shell">
  <div class="main-area">
    {% include "components/header.html" %}

    <div class="tabs">
      <button class="tab active" data-tab="dashboard">Dashboard</button>
      <button class="tab" data-tab="opportunities">Opportunities</button>
      <button class="tab" data-tab="trades">Trades</button>
      <button class="tab" data-tab="config">Config</button>
      <button class="tab" data-tab="logs">Logs</button>
      <button class="tab" data-tab="performance">Performance</button>
    </div>

    <div class="tab-section active" id="tab-dashboard">
      {% include "components/stats_cards.html" %}
      <div class="dashboard-split">
        {% include "components/opportunities.html" %}
        {% include "components/trades_table.html" %}
      </div>
    </div>

    <div class="tab-section" id="tab-opportunities">
      {% include "components/opportunities.html" %}
    </div>

    <div class="tab-section" id="tab-trades">
      {% include "components/trades_table.html" %}
    </div>

    <div class="tab-section" id="tab-config">
      {% include "components/config_panel.html" %}
    </div>

    <div class="tab-section" id="tab-logs">
      {% include "components/log_viewer.html" %}
    </div>

    <div class="tab-section" id="tab-performance">
      {% include "components/performance_panel.html" %}
    </div>
  </div>
</div>

<script>
  // ==========================================================================
  // STATE
  // ==========================================================================
  const state = {
    kalshi: {
      running: {{ 'true' if running else 'false' }},
      bankroll: {{ stats.bankroll }},
      pnl: {{ stats.total_pnl }},
    },
    config: {{ config | tojson }},
    stats: {{ stats | tojson }},
    oppCount: 0,
    currentPeriod: 'day',
    opportunities: [],
    performance: {
      source: 'paper',
      metrics: null,
      history: [],
      backtests: [],
      backtestSummary: null,
    },
  };

  // ==========================================================================
  // TIME-BASED CHART DATA GENERATION
  // ==========================================================================
  // 24h view: 12 PM (noon) -> 5 PM -> 12 AM (midnight) - 12 hour span
  // Data points every 30 mins = 25 points total
  function generate24hData() {
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();

    // Convert current time to position in 12-hour span (12 PM = 0, 12 AM = 12)
    let hoursFromNoon;
    if (currentHour >= 12) {
      hoursFromNoon = currentHour - 12 + currentMinute / 60;
    } else {
      hoursFromNoon = currentHour + 12 + currentMinute / 60; // past midnight
    }

    const labels = [];
    const data = [];
    const totalPoints = 25; // 0 to 24 = 25 points for 12 hours (every 30 min)

    for (let i = 0; i < totalPoints; i++) {
      const hourOffset = i * 0.5; // 30-min intervals
      const hour = 12 + hourOffset;
      const displayHour = hour >= 24 ? hour - 24 : hour;
      const isPM = displayHour >= 12 && displayHour < 24;
      const display12h = displayHour === 0 ? 12 : displayHour === 12 ? 12 : displayHour > 12 ? displayHour - 12 : displayHour;

      // Only show labels at 12 PM, 5 PM, 12 AM
      if (hourOffset === 0) {
        labels.push('12 PM');
      } else if (hourOffset === 5) {
        labels.push('5 PM');
      } else if (hourOffset === 12) {
        labels.push('12 AM');
      } else {
        labels.push('');
      }

      // Only show data up to current position
      const pointPosition = hourOffset;
      if (pointPosition <= hoursFromNoon) {
        data.push(state.kalshi.pnl);
      } else {
        data.push(null);
      }
    }

    return { labels, data };
  }

  // 7d view: Past 7 days with current day at the end
  function generate7dData() {
    const now = new Date();
    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const labels = [];
    const data = [];

    for (let i = 6; i >= 0; i--) {
      const d = new Date(now);
      d.setDate(d.getDate() - i);
      labels.push(dayNames[d.getDay()]);
      data.push(i === 0 ? state.kalshi.pnl : 0); // Only current day has P&L
    }

    return { labels, data };
  }

  let chartData24h = generate24hData();
  let chartData7d = generate7dData();

  // ==========================================================================
  // P&L CHART
  // ==========================================================================
  const ctx = document.getElementById('pnl-chart').getContext('2d');

  const gradientPositive = ctx.createLinearGradient(0, 0, 0, 160);
  gradientPositive.addColorStop(0, 'rgba(212, 175, 55, 0.35)');
  gradientPositive.addColorStop(0.6, 'rgba(212, 175, 55, 0.12)');
  gradientPositive.addColorStop(1, 'rgba(0, 0, 0, 0)');

  const gradientNegative = ctx.createLinearGradient(0, 0, 0, 160);
  gradientNegative.addColorStop(0, 'rgba(255, 107, 107, 0.3)');
  gradientNegative.addColorStop(0.6, 'rgba(255, 107, 107, 0.12)');
  gradientNegative.addColorStop(1, 'rgba(0, 0, 0, 0)');

  const pulsingDotPlugin = {
    id: 'pulsingDot',
    afterDatasetsDraw(chart) {
      const meta = chart.getDatasetMeta(0);
      if (!meta.data.length) return;

      // Find the last non-null data point
      const data = chart.data.datasets[0].data;
      let lastValidIndex = -1;
      for (let i = data.length - 1; i >= 0; i--) {
        if (data[i] !== null) {
          lastValidIndex = i;
          break;
        }
      }
      if (lastValidIndex < 0) return;

      const lastPoint = meta.data[lastValidIndex];
      if (!lastPoint) return;
      const { x, y } = lastPoint.tooltipPosition();
      const ctx = chart.ctx;
      const now = performance.now();
      const period = 1600;
      const t = (now % period) / period; // 0..1
      const baseRadius = 5;
      const pulseRadius = baseRadius + 6 * (1 - Math.abs(0.5 - t) * 2);

      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, pulseRadius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(212, 175, 55, 0.15)';
      ctx.fill();

      ctx.beginPath();
      ctx.arc(x, y, baseRadius, 0, Math.PI * 2);
      ctx.fillStyle = '#D4AF37';
      ctx.fill();
      ctx.restore();
    }
  };

  function computeScaleBounds(series) {
    const min = Math.min(...series, 0);
    const max = Math.max(...series, 0);
    const padding = Math.max(5, (max - min) * 0.15);
    return {
      suggestedMin: min - padding,
      suggestedMax: max + padding,
    };
  }

  const pnlChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: chartData24h.labels,
      datasets: [{
        label: 'P&L',
        data: chartData24h.data,
        fill: { target: { value: 0 } },
        backgroundColor: (context) => (context.raw ?? 0) >= 0 ? gradientPositive : gradientNegative,
        borderColor: (context) => (context.raw ?? 0) >= 0 ? '#D4AF37' : '#ff6b6b',
        borderWidth: 2,
        tension: 0.4,
        pointRadius: 0,
        pointHoverRadius: 4,
        pointHoverBackgroundColor: '#FFD060',
        pointHoverBorderColor: '#D4AF37',
        spanGaps: false,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: { duration: 400 },
      interaction: {
        intersect: false,
        mode: 'index',
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(10, 10, 0, 0.9)',
          borderColor: 'rgba(212, 175, 55, 0.3)',
          borderWidth: 1,
          titleColor: '#D4AF37',
          bodyColor: '#f5f5f5',
          padding: 10,
          displayColors: false,
          callbacks: {
            label: (ctx) => `P&L: $${ctx.raw >= 0 ? '+' : ''}${ctx.raw.toFixed(2)}`
          }
        }
      },
      scales: {
        x: {
          display: true,
          grid: { display: false },
          ticks: {
            color: '#666',
            font: { size: 10, family: "-apple-system, BlinkMacSystemFont, 'SF Mono', monospace", style: 'normal' },
            maxRotation: 0,
            autoSkip: true,
            maxTicksLimit: 8,
          },
          border: { display: false },
        },
        y: {
          display: false,
          grid: {
            display: true,
            drawTicks: false,
            color: (ctx) => (ctx.tick.value === 0 ? 'rgba(212, 175, 55, 0.35)' : 'rgba(255,255,255,0.05)'),
            borderDash: (ctx) => (ctx.tick.value === 0 ? [] : [4, 4]),
          },
          beginAtZero: false,
          suggestedMin: -10,
          suggestedMax: 10,
        }
      }
    },
    plugins: [pulsingDotPlugin],
  });

  let pulseAnimationId;
  function startPulse() {
    const render = () => {
      pnlChart.draw();
      pulseAnimationId = requestAnimationFrame(render);
    };
    render();
  }
  startPulse();

  function updatePnlChart(newPnl) {
    // Update P&L in state
    state.kalshi.pnl = newPnl;

    // Regenerate chart data based on current period
    chartData24h = generate24hData();
    chartData7d = generate7dData();

    const chartData = state.currentPeriod === 'day' ? chartData24h : chartData7d;
    pnlChart.data.labels = chartData.labels;
    pnlChart.data.datasets[0].data = chartData.data;

    const validData = chartData.data.filter(v => v !== null);
    const bounds = computeScaleBounds(validData.length ? validData : [0]);
    pnlChart.options.scales.y.suggestedMin = bounds.suggestedMin;
    pnlChart.options.scales.y.suggestedMax = bounds.suggestedMax;

    pnlChart.update('none');

    // Update header value
    const chartValue = document.getElementById('chart-pnl-value');
    chartValue.textContent = `$${newPnl >= 0 ? '+' : ''}${newPnl.toFixed(2)}`;
    chartValue.className = 'chart-value ' + (newPnl > 0 ? 'pnl-positive' : newPnl < 0 ? 'pnl-negative' : '');
  }

  // ==========================================================================
  // PERIOD TOGGLE (24h / 7d)
  // ==========================================================================
  const periodBtns = document.querySelectorAll('.period-btn');

  function switchPeriod(period) {
    state.currentPeriod = period;
    periodBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.period === period));

    // Regenerate chart data
    chartData24h = generate24hData();
    chartData7d = generate7dData();

    const chartData = period === 'day' ? chartData24h : chartData7d;
    pnlChart.data.labels = chartData.labels;
    pnlChart.data.datasets[0].data = chartData.data;

    const validData = chartData.data.filter(v => v !== null);
    const bounds = computeScaleBounds(validData.length ? validData : [0]);
    pnlChart.options.scales.y.suggestedMin = bounds.suggestedMin;
    pnlChart.options.scales.y.suggestedMax = bounds.suggestedMax;

    pnlChart.update();
  }

  periodBtns.forEach(btn => {
    btn.addEventListener('click', () => switchPeriod(btn.dataset.period));
  });

  // ==========================================================================
  // TAB NAVIGATION
  // ==========================================================================
  const tabs = document.querySelectorAll('.tab');
  const sections = {
    dashboard: document.getElementById('tab-dashboard'),
    opportunities: document.getElementById('tab-opportunities'),
    trades: document.getElementById('tab-trades'),
    config: document.getElementById('tab-config'),
    logs: document.getElementById('tab-logs'),
    performance: document.getElementById('tab-performance'),
  };

  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      Object.values(sections).forEach(sec => sec.classList.remove('active'));
      sections[tab.dataset.tab].classList.add('active');
    });
  });

  // ==========================================================================
  // KALSHI CONTROLS
  // ==========================================================================
  const kalshiStartBtn = document.getElementById('kalshi-start-btn');
  const kalshiStatus = document.getElementById('kalshi-status');
  const kalshiBankroll = document.getElementById('kalshi-bankroll');

  kalshiStartBtn?.addEventListener('click', async () => {
    const wasRunning = state.kalshi.running;
    const endpoint = wasRunning ? '/api/stop' : '/api/start';
    
    // Show transitional state
    kalshiStartBtn.disabled = true;
    kalshiStartBtn.textContent = wasRunning ? 'Stopping...' : 'Starting...';
    kalshiStatus.textContent = wasRunning ? 'Stopping...' : 'Starting...';
    kalshiStatus.classList.remove('status-on', 'status-off');
    kalshiStatus.classList.add('status-pending');
    
    try {
      const res = await fetch(endpoint, { method: 'POST' });
      const data = await res.json();
      state.kalshi.running = data.running;
      if (data.stats) {
        state.stats = data.stats;
        state.kalshi.bankroll = data.stats.bankroll;
        state.kalshi.pnl = data.stats.total_pnl;
      }
      refreshKalshiStatus(wasRunning);
      updateStats(state.stats);
    } catch (err) {
      // Revert on error
      state.kalshi.running = wasRunning;
      refreshKalshiStatus();
    } finally {
      kalshiStartBtn.disabled = false;
    }
  });

  function refreshKalshiStatus(wasRunning = null) {
    kalshiStatus.textContent = state.kalshi.running ? "PRINTIN'" : 'Inactive';
    kalshiStatus.classList.remove('status-on', 'status-off', 'status-pending');
    kalshiStatus.classList.add(state.kalshi.running ? 'status-on' : 'status-off');
    kalshiStartBtn.textContent = state.kalshi.running ? 'Stop' : 'Start';
    kalshiStartBtn.classList.toggle('engine-active', state.kalshi.running);
    
    // Toggle gold tracer effect based on engine running state
    const tickerCard = document.getElementById('ticker-kalshi');
    tickerCard.classList.toggle('engine-running', state.kalshi.running);
    
    // Apply flicker effects on state change
    if (wasRunning !== null && wasRunning !== state.kalshi.running) {
      kalshiStartBtn.classList.remove('flicker-on', 'flicker-off');
      if (state.kalshi.running) {
        // Turned on - flicker on
        kalshiStartBtn.classList.add('flicker-on');
      } else {
        // Turned off - flicker off
        kalshiStartBtn.classList.add('flicker-off');
      }
      // Remove the class after animation completes
      setTimeout(() => {
        kalshiStartBtn.classList.remove('flicker-on', 'flicker-off');
      }, 600);
    }
  }

  // ==========================================================================
  // UPLINK BUTTON
  // ==========================================================================
  const uplinkBtn = document.getElementById('kalshi-uplink-btn');
  const uplinkStatusPill = document.getElementById('uplink-status-pill');
  const uplinkErrorMsg = document.getElementById('uplink-error-msg');

  function setUplinkBtnState(state) {
    if (!uplinkBtn) return;
    uplinkBtn.classList.remove('checking', 'connected', 'disconnected');
    if (state) uplinkBtn.classList.add(state);
  }

  uplinkBtn?.addEventListener('click', async () => {
    // Set checking state
    uplinkStatusPill.className = 'ticker-tag status-pill checking';
    uplinkStatusPill.textContent = 'Checking...';
    uplinkErrorMsg.textContent = '';
    setUplinkBtnState('checking');
    uplinkBtn.disabled = true;

    try {
      const res = await fetch('/api/uplink', { method: 'POST' });
      const data = await res.json();

      if (data.connected) {
        uplinkStatusPill.className = 'ticker-tag status-pill connected';
        uplinkStatusPill.textContent = 'Connected';
        uplinkErrorMsg.textContent = '';
        setUplinkBtnState('connected');
        // Add green border effect for uplink connected
        document.getElementById('ticker-kalshi').classList.add('uplink-connected');
        // Update balance if returned
        if (data.balance !== undefined) {
          state.kalshi.bankroll = data.balance;
          kalshiBankroll.textContent = `$${data.balance.toFixed(2)}`;
        }
        // Update P&L chart with real data
        if (data.pnl !== undefined) {
          updatePnlChart(data.pnl);
        }
      } else {
        uplinkStatusPill.className = 'ticker-tag status-pill disconnected';
        uplinkStatusPill.textContent = 'Disconnected';
        uplinkErrorMsg.textContent = data.error || 'Connection failed';
        setUplinkBtnState('disconnected');
        // Remove green border effect
        document.getElementById('ticker-kalshi').classList.remove('uplink-connected');
      }
    } catch (err) {
      uplinkStatusPill.className = 'ticker-tag status-pill disconnected';
      uplinkStatusPill.textContent = 'Error';
      uplinkErrorMsg.textContent = err.message || 'Network error';
      setUplinkBtnState('disconnected');
      // Remove green border effect
      document.getElementById('ticker-kalshi').classList.remove('uplink-connected');
    } finally {
      uplinkBtn.disabled = false;
    }
  });

  // ==========================================================================
  // STATS UPDATER
  // ==========================================================================
  function updateStats(stats) {
    state.stats = stats;
    state.kalshi.bankroll = stats.bankroll;
    state.kalshi.pnl = stats.total_pnl;

    // Update dashboard stats cards
    const rrEl = document.getElementById('stat-rr');
    rrEl.textContent = stats.trades > 0 ? stats.avg_rr.toFixed(2) : '--';
    document.getElementById('stat-trades').textContent = stats.trades;
    document.getElementById('stat-winrate').textContent = stats.trades > 0 ? `${stats.win_rate.toFixed(1)}%` : '--%';
    document.getElementById('stat-wins').textContent = stats.wins;
    document.getElementById('stat-losses').textContent = stats.losses;

    // Update Kalshi ticker
    kalshiBankroll.textContent = `$${state.kalshi.bankroll.toFixed(2)}`;

    // Update P&L chart
    updatePnlChart(stats.total_pnl);
  }

  // ==========================================================================
  // PERFORMANCE (7d) + BACKTESTING
  // ==========================================================================
  const perfCtx = document.getElementById('perf-chart')?.getContext('2d');
  let perfChart = null;

  function renderPerformanceChart(daily = []) {
    if (!perfCtx) return;
    const labels = daily.map(d => d.date?.slice(5) || '');
    const data = daily.map(d => d.pnl ?? 0);
    const bounds = computeScaleBounds(data.length ? data : [0]);
    const dataset = {
      label: 'Daily P&L',
      data,
      backgroundColor: data.map(v => (v >= 0 ? 'rgba(0, 200, 120, 0.35)' : 'rgba(255, 107, 107, 0.35)')),
      borderColor: data.map(v => (v >= 0 ? '#00c878' : '#ff6b6b')),
      borderWidth: 1.5,
    };
    if (!perfChart) {
      perfChart = new Chart(perfCtx, {
        type: 'bar',
        data: { labels, datasets: [dataset] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              suggestedMin: bounds.suggestedMin,
              suggestedMax: bounds.suggestedMax,
              grid: { color: 'rgba(255,255,255,0.05)' },
            },
            x: { grid: { display: false } },
          },
          plugins: { legend: { display: false } },
        },
      });
    } else {
      perfChart.data.labels = labels;
      perfChart.data.datasets[0].data = data;
      perfChart.options.scales.y.suggestedMin = bounds.suggestedMin;
      perfChart.options.scales.y.suggestedMax = bounds.suggestedMax;
      perfChart.update();
    }
  }

  function renderPerformanceHistory(rows = []) {
    const body = document.getElementById('perf-history-body');
    if (!body) return;
    body.innerHTML = '';
    if (!rows.length) {
      body.innerHTML = '<tr><td colspan="7" class="muted">No trades yet.</td></tr>';
      return;
    }
    rows.forEach((row) => {
      const pnlClass = row.pnl > 0 ? 'pnl-positive' : row.pnl < 0 ? 'pnl-negative' : '';
      const resultClass = row.pnl > 0 ? 'badge-win' : row.pnl < 0 ? 'badge-loss' : 'badge-pending';
      const ts = row.ts ? new Date(row.ts * 1000).toLocaleString() : '--';
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${ts}</td>
        <td>${row.matchup || '--'}</td>
        <td>${row.team || '--'}</td>
        <td>${(row.edge || 0).toFixed(2)}%</td>
        <td>$${Number(row.stake || 0).toFixed(2)}</td>
        <td><span class="badge ${resultClass}">${row.result || 'PENDING'}</span></td>
        <td class="${pnlClass}">${row.pnl >= 0 ? '+' : ''}${Number(row.pnl || 0).toFixed(2)}</td>
      `;
      body.appendChild(tr);
    });
  }

  function updatePerformanceUI(payload, source) {
    state.performance.source = source;
    state.performance.metrics = payload.metrics;
    state.performance.history = payload.history;
    const m = payload.metrics || {};
    document.getElementById('perf-pnl').textContent = fmt.currency(m.pnl);
    document.getElementById('perf-winrate').textContent = fmt.pct(m.win_rate);
    document.getElementById('perf-roi').textContent = fmt.pct(m.roi);
    document.getElementById('perf-edge').textContent = `${Number(m.avg_edge || 0).toFixed(2)}%`;
    document.getElementById('perf-chart-pnl').textContent = fmt.currency(m.pnl);
    document.getElementById('perf-trade-count').textContent = `${m.trades || 0} trades`;
    renderPerformanceChart(m.daily || []);
    renderPerformanceHistory(payload.history || []);
  }

  async function fetchPerformance(source = 'paper') {
    const res = await fetch(`/api/performance?source=${source}`);
    const data = await res.json();
    updatePerformanceUI(data, source);
    document.querySelectorAll('#performance-source-toggle .pill-btn').forEach((btn) => {
      btn.classList.toggle('active', btn.dataset.source === source);
    });
  }

  // Backtest UI helpers
  function updateBacktestSummary(summary = {}) {
    document.getElementById('bt-trades').textContent = summary.trades ?? '--';
    document.getElementById('bt-winrate').textContent = summary.win_rate !== undefined ? fmt.pct(summary.win_rate) : '--';
    document.getElementById('bt-pnl').textContent = summary.pnl !== undefined ? fmt.currency(summary.pnl) : '--';
    document.getElementById('bt-roi').textContent = summary.roi !== undefined ? fmt.pct(summary.roi) : '--';
    document.getElementById('bt-sharpe').textContent = summary.sharpe ?? '--';
    document.getElementById('bt-dd').textContent = summary.max_drawdown !== undefined ? fmt.currency(summary.max_drawdown) : '--';
  }

  function renderBacktestHistory(rows = []) {
    const body = document.getElementById('backtest-history-body');
    body.innerHTML = '';
    if (!rows.length) {
      body.innerHTML = '<tr><td colspan="6" class="muted">No backtests yet.</td></tr>';
      return;
    }
    rows.forEach((row) => {
      const summary = row.summary || {};
      const tr = document.createElement('tr');
      const created = row.created_at ? new Date(row.created_at * 1000).toLocaleString() : '--';
      tr.innerHTML = `
        <td>${created}</td>
        <td>${row.sports}</td>
        <td>${row.start_date} â†’ ${row.end_date}</td>
        <td>${summary.pnl !== undefined ? fmt.currency(summary.pnl) : '--'}</td>
        <td>${summary.win_rate !== undefined ? fmt.pct(summary.win_rate) : '--'}</td>
        <td>${summary.roi !== undefined ? fmt.pct(summary.roi) : '--'}</td>
      `;
      body.appendChild(tr);
    });
  }

  async function refreshBacktestHistory() {
    const res = await fetch('/api/backtest/history');
    const rows = await res.json();
    renderBacktestHistory(rows);
  }

  async function runBacktest(payload) {
    const btn = document.getElementById('backtest-run-btn');
    btn.disabled = true;
    btn.textContent = 'Running...';
    try {
      const res = await fetch('/api/backtest', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const data = await res.json();
      updateBacktestSummary(data.summary || {});
      await refreshBacktestHistory();
    } finally {
      btn.disabled = false;
      btn.textContent = 'Run Backtest';
    }
  }

  function initPerformance() {
    const yesterday = new Date(Date.now() - 7 * 86400000).toISOString().slice(0, 10);
    const today = new Date().toISOString().slice(0, 10);
    document.getElementById('backtest-start').value = yesterday;
    document.getElementById('backtest-end').value = today;
    document.getElementById('backtest-sports').value = (state.config.sports || []).join(',');

    document.querySelectorAll('#performance-source-toggle .pill-btn').forEach((btn) => {
      btn.addEventListener('click', () => fetchPerformance(btn.dataset.source));
    });

    const backtestForm = document.getElementById('backtest-form');
    backtestForm?.addEventListener('submit', (e) => {
      e.preventDefault();
      const sports = (document.getElementById('backtest-sports').value || '').split(',').map(s => s.trim()).filter(Boolean);
      const payload = {
        sports: sports.length ? sports : state.config.sports,
        start_date: document.getElementById('backtest-start').value,
        end_date: document.getElementById('backtest-end').value,
        stake: parseFloat(document.getElementById('backtest-stake').value || '10'),
        edge_threshold: parseFloat(document.getElementById('backtest-edge').value || '0.05'),
      };
      runBacktest(payload);
    });

    fetchPerformance('paper');
    refreshBacktestHistory();
  }

  // ==========================================================================
  // CONFIG FORM
  // ==========================================================================
  const configForm = document.getElementById('config-form');
  const resetBtn = document.getElementById('reset-config');

  configForm?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const formData = new FormData(configForm);
    const payload = {};
    formData.forEach((v, k) => payload[k] = v);
    payload.kelly_multiplier = parseFloat(payload.kelly_multiplier);
    payload.target_buy_ev = parseFloat(payload.target_buy_ev);
    payload.target_sell_ev = parseFloat(payload.target_sell_ev);
    payload.max_percentage_bet = parseFloat(payload.max_percentage_bet);
    payload.max_dollar_bet = parseFloat(payload.max_dollar_bet);
    payload.min_true_prob = parseFloat(payload.min_true_prob);
    payload.max_true_prob = parseFloat(payload.max_true_prob);
    payload.trading_start = parseInt(payload.trading_start, 10);
    payload.trading_end = parseInt(payload.trading_end, 10);
    payload.sports = (payload.sports || '').split(',').map(s => s.trim()).filter(Boolean);
    payload.boltodds_api_key = payload.boltodds_api_key || '';

    const res = await fetch('/api/config', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    const data = await res.json();
    state.config = data.config;
    appendLog('[Config] Settings saved successfully');
  });

  resetBtn?.addEventListener('click', () => {
    configForm.reset();
    // Reset sport chips to default
    document.querySelectorAll('.sport-chip').forEach(chip => {
      const defaultSports = ['NBA', 'NFL', 'NHL'];
      chip.classList.toggle('active', defaultSports.includes(chip.dataset.sport));
    });
    updateSportsInput();
  });

  // Sport Chips Handler
  const sportChips = document.querySelectorAll('.sport-chip');
  const sportsInput = document.getElementById('sports-input');

  function updateSportsInput() {
    const activeSports = Array.from(document.querySelectorAll('.sport-chip.active'))
      .map(chip => chip.dataset.sport);
    sportsInput.value = activeSports.join(',');
  }

  sportChips.forEach(chip => {
    chip.addEventListener('click', () => {
      chip.classList.toggle('active');
      updateSportsInput();
    });
  });

  // ==========================================================================
  // SSE STREAMS
  // ==========================================================================
  const logArea = document.getElementById('log-area');
  const oppBody = document.getElementById('opportunities-body');
  const tradesBody = document.getElementById('trades-body');
  const oppSearch = document.getElementById('opp-search');
  const oppSort = document.getElementById('opp-sort');
  const oppSportFilter = document.getElementById('opp-sport-filter');

  function appendLog(line) {
    const div = document.createElement('div');
    div.textContent = line;
    logArea.appendChild(div);
    logArea.scrollTop = logArea.scrollHeight;
  }

  document.getElementById('clear-logs')?.addEventListener('click', () => {
    logArea.innerHTML = '';
  });

  function renderOpportunities() {
    const searchTerm = (oppSearch?.value || '').toLowerCase();
    const sportFilter = (oppSportFilter?.value || '').toLowerCase();
    const sortKey = oppSort?.value || 'timestamp';

    const filtered = state.opportunities
      .filter((opp) => {
        const matchesSearch = opp.matchup.toLowerCase().includes(searchTerm) || opp.team.toLowerCase().includes(searchTerm);
        const matchesSport = !sportFilter || (opp.sport || '').toLowerCase() === sportFilter;
        return matchesSearch && matchesSport;
      })
      .sort((a, b) => {
        if (sortKey === 'edge') return b.edge - a.edge;
        if (sortKey === 'stake') return (b.kelly_stake || 0) - (a.kelly_stake || 0);
        return (b.timestamp || 0) - (a.timestamp || 0);
      });

    // Render to all kanban containers (dashboard + opportunities tab)
    document.querySelectorAll('.opportunities-kanban').forEach(kanban => {
      kanban.innerHTML = '';
      if (!filtered.length) {
        kanban.innerHTML = '<div class="opp-empty-state"><span class="muted">No opportunities match the filters.</span></div>';
        return;
      }

      filtered.slice(0, 20).forEach((opp) => {
        const stake = Number(opp.kelly_stake ?? 0);
        const pppOdds = Number(opp.true_prob ?? 0);
        const mktOdds = Number(opp.market_prob ?? 0);
        const edge = Number(opp.edge ?? 0);
        const ts = opp.timestamp ? new Date(opp.timestamp * 1000).toLocaleTimeString() : '--';
        const isPositive = edge > 0;
        
        const row = document.createElement('div');
        row.className = `opp-row ${isPositive ? 'positive' : 'negative'}`;
        row.dataset.matchup = opp.matchup;
        
        // Determine pill classes based on values
        const edgePillClass = edge > 0 ? 'pill-positive' : edge < 0 ? 'pill-negative' : 'pill-neutral';
        const pppPillClass = pppOdds > mktOdds ? 'pill-positive' : pppOdds < mktOdds ? 'pill-negative' : 'pill-neutral';
        const mktPillClass = 'pill-neutral';
        const stakePillClass = stake > 0 ? 'pill-positive' : 'pill-neutral';
        
        row.innerHTML = `
          <div class="opp-cell">
            <span class="opp-label">Matchup</span>
            <span class="opp-matchup">${opp.matchup}</span>
          </div>
          <div class="opp-cell">
            <span class="opp-label">Position</span>
            <span class="opp-position">${opp.team}</span>
          </div>
          <div class="opp-cell">
            <span class="opp-label">PPP Odds</span>
            <span class="${pppPillClass}">${(pppOdds * 100).toFixed(1)}%</span>
          </div>
          <div class="opp-cell">
            <span class="opp-label">MKT Odds</span>
            <span class="${mktPillClass}">${(mktOdds * 100).toFixed(1)}%</span>
          </div>
          <div class="opp-cell">
            <span class="opp-label">Edge</span>
            <span class="${edgePillClass}">${edge >= 0 ? '+' : ''}${edge.toFixed(2)}%</span>
          </div>
          <div class="opp-cell">
            <span class="opp-label">Stake</span>
            <span class="${stakePillClass}">$${stake.toFixed(2)}</span>
          </div>
          <div class="opp-cell">
            <span class="opp-timestamp">${ts}</span>
          </div>
        `;
        kanban.appendChild(row);
      });
    });
  }

  oppSearch?.addEventListener('input', renderOpportunities);
  oppSort?.addEventListener('change', renderOpportunities);
  oppSportFilter?.addEventListener('change', renderOpportunities);

  function addOpportunity(opp) {
    state.oppCount += 1;
    
    // Check if this matchup already exists (for flicker effect)
    const existingIdx = state.opportunities.findIndex(o => o.matchup === opp.matchup && o.team === opp.team);
    const isUpdate = existingIdx !== -1;
    
    if (isUpdate) {
      // Remove old entry
      state.opportunities.splice(existingIdx, 1);
    }
    
    state.opportunities.unshift(opp);
    if (state.opportunities.length > 200) {
      state.opportunities.pop();
    }
    renderOpportunities();
    
    // Add flicker effect for updates
    if (isUpdate) {
      const kanban = document.getElementById('opportunities-kanban');
      const row = kanban?.querySelector(`[data-matchup="${opp.matchup}"]`);
      if (row) {
        row.classList.add('flicker-update');
        setTimeout(() => row.classList.remove('flicker-update'), 600);
      }
    }
  }

  function addTrade(trade) {
    // Add to all trade tables (dashboard split + trades tab)
    document.querySelectorAll('#trades-body').forEach(tradesBody => {
      const tr = document.createElement('tr');
      tr.className = `trade-row ${trade.result === 'WIN' ? 'win' : 'loss'}`;
      const pnlClass = trade.pnl > 0 ? 'pnl-positive' : trade.pnl < 0 ? 'pnl-negative' : '';
      const badgeClass = trade.result === 'WIN' ? 'badge-win' : trade.result === 'LOSS' ? 'badge-loss' : 'badge-pending';
      tr.innerHTML = `
        <td>${new Date(trade.timestamp * 1000).toLocaleTimeString()}</td>
        <td>${trade.matchup}</td>
        <td>${trade.team}</td>
        <td>${(trade.entry_price * 100).toFixed(1)}%</td>
        <td>$${trade.stake.toFixed(2)}</td>
        <td>${trade.edge.toFixed(2)}%</td>
        <td><span class="badge ${badgeClass}">${trade.result}</span></td>
        <td class="${pnlClass}">${trade.pnl >= 0 ? '+' : ''}${trade.pnl.toFixed(2)}</td>
      `;
      if (tradesBody.children.length === 1 && tradesBody.children[0].querySelector('.muted')) {
        tradesBody.innerHTML = '';
      }
      tradesBody.prepend(tr);
      while (tradesBody.children.length > 50) {
        tradesBody.removeChild(tradesBody.lastChild);
      }
    });
  }

  // Log stream
  const logStream = new EventSource('/stream/logs');
  logStream.onmessage = (event) => {
    const data = JSON.parse(event.data);
    appendLog(data.log);
  };

  // Opportunity stream
  const oppStream = new EventSource('/stream/opportunities');
  oppStream.onmessage = (event) => {
    const data = JSON.parse(event.data);
    addOpportunity(data);
  };

  // Trades stream
  const tradeStream = new EventSource('/stream/trades');
  tradeStream.onmessage = (event) => {
    const trade = JSON.parse(event.data);
    addTrade(trade);
    fetch('/api/stats')
      .then(r => r.json())
      .then(stats => updateStats(stats));
  };

  // Periodic stats refresh for live Kalshi balance/P&L
  setInterval(() => {
    fetch('/api/stats')
      .then(r => r.json())
      .then(stats => updateStats(stats))
      .catch(() => { });
  }, 10000);

  // Initial render
  refreshKalshiStatus();
  updateStats(state.stats);
  renderOpportunities();
  initPerformance();
</script>
{% endblock %}