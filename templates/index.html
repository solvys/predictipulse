{% extends "base.html" %}

{% block content %}
<div class="app-shell">
  <div class="main-area">
    {% include "components/header.html" %}

    <div class="tabs">
      <button class="tab active" data-tab="dashboard">Dashboard</button>
      <button class="tab" data-tab="opportunities">Opportunities</button>
      <button class="tab" data-tab="trades">Trades</button>
      <button class="tab" data-tab="config">Config</button>
      <button class="tab" data-tab="logs">Logs</button>
      <button class="tab" data-tab="performance">Performance</button>
    </div>

    <div class="tab-section active" id="tab-dashboard">
      {% include "components/stats_cards.html" %}
      <div class="dashboard-split">
        {% include "components/opportunities.html" %}
        {% include "components/trades_table.html" %}
      </div>
    </div>

    <div class="tab-section" id="tab-opportunities">
      {% include "components/opportunities.html" %}
    </div>

    <div class="tab-section" id="tab-trades">
      {% include "components/trades_table.html" %}
    </div>

    <div class="tab-section" id="tab-config">
      {% include "components/config_panel.html" %}
    </div>

    <div class="tab-section" id="tab-logs">
      {% include "components/log_viewer.html" %}
    </div>

    <div class="tab-section" id="tab-performance">
      {% include "components/performance_panel.html" %}
    </div>
  </div>
</div>

<!-- iOS 26 Style Calendar Picker -->
<div id="calendar-picker-overlay" class="calendar-overlay">
  <div class="calendar-picker">
    <div class="calendar-header">
      <button type="button" class="calendar-close" id="calendar-close">×</button>
      <h3 class="calendar-title">Select Date Range</h3>
    </div>
    <div class="calendar-body">
      <!-- Start Date Calendar -->
      <div class="calendar-date-section">
        <div class="calendar-date-label">Start Date</div>
        <div class="calendar-nav">
          <button type="button" class="calendar-nav-btn" id="start-prev-month">‹</button>
          <div class="calendar-month-year" id="start-month-year">January 2025</div>
          <button type="button" class="calendar-nav-btn" id="start-next-month">›</button>
        </div>
        <div class="calendar-grid" id="start-calendar-grid">
          <div class="calendar-weekdays">
            <div class="calendar-weekday">S</div>
            <div class="calendar-weekday">M</div>
            <div class="calendar-weekday">T</div>
            <div class="calendar-weekday">W</div>
            <div class="calendar-weekday">T</div>
            <div class="calendar-weekday">F</div>
            <div class="calendar-weekday">S</div>
          </div>
          <div class="calendar-days" id="start-calendar-days"></div>
        </div>
      </div>
      
      <!-- End Date Calendar -->
      <div class="calendar-date-section">
        <div class="calendar-date-label">End Date</div>
        <div class="calendar-nav">
          <button type="button" class="calendar-nav-btn" id="end-prev-month">‹</button>
          <div class="calendar-month-year" id="end-month-year">January 2025</div>
          <button type="button" class="calendar-nav-btn" id="end-next-month">›</button>
        </div>
        <div class="calendar-grid" id="end-calendar-grid">
          <div class="calendar-weekdays">
            <div class="calendar-weekday">S</div>
            <div class="calendar-weekday">M</div>
            <div class="calendar-weekday">T</div>
            <div class="calendar-weekday">W</div>
            <div class="calendar-weekday">T</div>
            <div class="calendar-weekday">F</div>
            <div class="calendar-weekday">S</div>
          </div>
          <div class="calendar-days" id="end-calendar-days"></div>
        </div>
      </div>
    </div>
    <div class="calendar-footer">
      <button type="button" class="calendar-btn calendar-btn-cancel" id="calendar-cancel">Cancel</button>
      <button type="button" class="calendar-btn calendar-btn-confirm" id="calendar-confirm">Done</button>
    </div>
  </div>
</div>

<script>
  // ==========================================================================
  // STATE
  // ==========================================================================
  const state = {
    kalshi: {
      running: {{ 'true' if running else 'false' }},
      bankroll: {{ stats.bankroll }},
      pnl: {{ stats.total_pnl }},
    },
    config: {{ config | tojson }},
    stats: {{ stats | tojson }},
    oppCount: 0,
    currentPeriod: 'day',
    opportunities: [],
    performance: {
      source: 'paper',
      metrics: null,
      history: [],
      backtests: [],
      backtestSummary: null,
    },
  };

  // ==========================================================================
  // TIME-BASED CHART DATA GENERATION
  // ==========================================================================
  // 24h view: 12 PM (noon) -> 5 PM -> 12 AM (midnight) - 12 hour span
  // Data points every 30 mins = 25 points total
  function generate24hData() {
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();

    // Convert current time to position in 12-hour span (12 PM = 0, 12 AM = 12)
    let hoursFromNoon;
    if (currentHour >= 12) {
      hoursFromNoon = currentHour - 12 + currentMinute / 60;
    } else {
      hoursFromNoon = currentHour + 12 + currentMinute / 60; // past midnight
    }

    const labels = [];
    const data = [];
    const totalPoints = 25; // 0 to 24 = 25 points for 12 hours (every 30 min)

    for (let i = 0; i < totalPoints; i++) {
      const hourOffset = i * 0.5; // 30-min intervals
      const hour = 12 + hourOffset;
      const displayHour = hour >= 24 ? hour - 24 : hour;
      const isPM = displayHour >= 12 && displayHour < 24;
      const display12h = displayHour === 0 ? 12 : displayHour === 12 ? 12 : displayHour > 12 ? displayHour - 12 : displayHour;

      // Only show labels at 12 PM, 5 PM, 12 AM
      if (hourOffset === 0) {
        labels.push('12 PM');
      } else if (hourOffset === 5) {
        labels.push('5 PM');
      } else if (hourOffset === 12) {
        labels.push('12 AM');
      } else {
        labels.push('');
      }

      // Only show data up to current position
      const pointPosition = hourOffset;
      if (pointPosition <= hoursFromNoon) {
        data.push(state.kalshi.pnl);
      } else {
        data.push(null);
      }
    }

    return { labels, data };
  }

  // 7d view: Past 7 days with current day at the end
  function generate7dData() {
    const now = new Date();
    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const labels = [];
    const data = [];

    for (let i = 6; i >= 0; i--) {
      const d = new Date(now);
      d.setDate(d.getDate() - i);
      labels.push(dayNames[d.getDay()]);
      data.push(i === 0 ? state.kalshi.pnl : 0); // Only current day has P&L
    }

    return { labels, data };
  }

  let chartData24h = generate24hData();
  let chartData7d = generate7dData();

  // ==========================================================================
  // P&L CHART
  // ==========================================================================
  const ctx = document.getElementById('pnl-chart').getContext('2d');

  const gradientPositive = ctx.createLinearGradient(0, 0, 0, 160);
  gradientPositive.addColorStop(0, 'rgba(212, 175, 55, 0.35)');
  gradientPositive.addColorStop(0.6, 'rgba(212, 175, 55, 0.12)');
  gradientPositive.addColorStop(1, 'rgba(0, 0, 0, 0)');

  const gradientNegative = ctx.createLinearGradient(0, 0, 0, 160);
  gradientNegative.addColorStop(0, 'rgba(255, 107, 107, 0.3)');
  gradientNegative.addColorStop(0.6, 'rgba(255, 107, 107, 0.12)');
  gradientNegative.addColorStop(1, 'rgba(0, 0, 0, 0)');

  const pulsingDotPlugin = {
    id: 'pulsingDot',
    afterDatasetsDraw(chart) {
      const meta = chart.getDatasetMeta(0);
      if (!meta.data.length) return;

      // Find the last non-null data point
      const data = chart.data.datasets[0].data;
      let lastValidIndex = -1;
      for (let i = data.length - 1; i >= 0; i--) {
        if (data[i] !== null) {
          lastValidIndex = i;
          break;
        }
      }
      if (lastValidIndex < 0) return;

      const lastPoint = meta.data[lastValidIndex];
      if (!lastPoint) return;
      const { x, y } = lastPoint.tooltipPosition();
      const ctx = chart.ctx;
      const now = performance.now();
      const period = 1600;
      const t = (now % period) / period; // 0..1
      const baseRadius = 5;
      const pulseRadius = baseRadius + 6 * (1 - Math.abs(0.5 - t) * 2);

      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, pulseRadius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(212, 175, 55, 0.15)';
      ctx.fill();

      ctx.beginPath();
      ctx.arc(x, y, baseRadius, 0, Math.PI * 2);
      ctx.fillStyle = '#D4AF37';
      ctx.fill();
      ctx.restore();
    }
  };

  function computeScaleBounds(series) {
    const min = Math.min(...series, 0);
    const max = Math.max(...series, 0);
    const padding = Math.max(5, (max - min) * 0.15);
    return {
      suggestedMin: min - padding,
      suggestedMax: max + padding,
    };
  }

  const pnlChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: chartData24h.labels,
      datasets: [{
        label: 'P&L',
        data: chartData24h.data,
        fill: { target: { value: 0 } },
        backgroundColor: (context) => (context.raw ?? 0) >= 0 ? gradientPositive : gradientNegative,
        borderColor: (context) => (context.raw ?? 0) >= 0 ? '#D4AF37' : '#ff6b6b',
        borderWidth: 2,
        tension: 0.4,
        pointRadius: 0,
        pointHoverRadius: 4,
        pointHoverBackgroundColor: '#FFD060',
        pointHoverBorderColor: '#D4AF37',
        spanGaps: false,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: { duration: 400 },
      interaction: {
        intersect: false,
        mode: 'index',
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(10, 10, 0, 0.9)',
          borderColor: 'rgba(212, 175, 55, 0.3)',
          borderWidth: 1,
          titleColor: '#D4AF37',
          bodyColor: '#f5f5f5',
          padding: 10,
          displayColors: false,
          callbacks: {
            label: (ctx) => `P&L: $${ctx.raw >= 0 ? '+' : ''}${ctx.raw.toFixed(2)}`
          }
        }
      },
      scales: {
        x: {
          display: true,
          grid: { display: false },
          ticks: {
            color: '#666',
            font: { size: 10, family: "-apple-system, BlinkMacSystemFont, 'SF Mono', monospace", style: 'normal' },
            maxRotation: 0,
            autoSkip: true,
            maxTicksLimit: 8,
          },
          border: { display: false },
        },
        y: {
          display: false,
          grid: {
            display: true,
            drawTicks: false,
            color: (ctx) => (ctx.tick.value === 0 ? 'rgba(212, 175, 55, 0.35)' : 'rgba(255,255,255,0.05)'),
            borderDash: (ctx) => (ctx.tick.value === 0 ? [] : [4, 4]),
          },
          beginAtZero: false,
          suggestedMin: -10,
          suggestedMax: 10,
        }
      }
    },
    plugins: [pulsingDotPlugin],
  });

  let pulseAnimationId;
  function startPulse() {
    const render = () => {
      pnlChart.draw();
      pulseAnimationId = requestAnimationFrame(render);
    };
    render();
  }
  startPulse();

  function updatePnlChart(newPnl) {
    // Update P&L in state
    state.kalshi.pnl = newPnl;

    // Regenerate chart data based on current period
    chartData24h = generate24hData();
    chartData7d = generate7dData();

    const chartData = state.currentPeriod === 'day' ? chartData24h : chartData7d;
    pnlChart.data.labels = chartData.labels;
    pnlChart.data.datasets[0].data = chartData.data;

    const validData = chartData.data.filter(v => v !== null);
    const bounds = computeScaleBounds(validData.length ? validData : [0]);
    pnlChart.options.scales.y.suggestedMin = bounds.suggestedMin;
    pnlChart.options.scales.y.suggestedMax = bounds.suggestedMax;

    pnlChart.update('none');

    // Update header value
    const chartValue = document.getElementById('chart-pnl-value');
    chartValue.textContent = `$${newPnl >= 0 ? '+' : ''}${newPnl.toFixed(2)}`;
    chartValue.className = 'chart-value ' + (newPnl > 0 ? 'pnl-positive' : newPnl < 0 ? 'pnl-negative' : '');
  }

  // ==========================================================================
  // PERIOD TOGGLE (24h / 7d)
  // ==========================================================================
  const periodBtns = document.querySelectorAll('.period-btn');

  function switchPeriod(period) {
    state.currentPeriod = period;
    periodBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.period === period));

    // Regenerate chart data
    chartData24h = generate24hData();
    chartData7d = generate7dData();

    const chartData = period === 'day' ? chartData24h : chartData7d;
    pnlChart.data.labels = chartData.labels;
    pnlChart.data.datasets[0].data = chartData.data;

    const validData = chartData.data.filter(v => v !== null);
    const bounds = computeScaleBounds(validData.length ? validData : [0]);
    pnlChart.options.scales.y.suggestedMin = bounds.suggestedMin;
    pnlChart.options.scales.y.suggestedMax = bounds.suggestedMax;

    pnlChart.update();
  }

  periodBtns.forEach(btn => {
    btn.addEventListener('click', () => switchPeriod(btn.dataset.period));
  });

  // ==========================================================================
  // TAB NAVIGATION
  // ==========================================================================
  const tabs = document.querySelectorAll('.tab');
  const sections = {
    dashboard: document.getElementById('tab-dashboard'),
    opportunities: document.getElementById('tab-opportunities'),
    trades: document.getElementById('tab-trades'),
    config: document.getElementById('tab-config'),
    logs: document.getElementById('tab-logs'),
    performance: document.getElementById('tab-performance'),
  };

  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      Object.values(sections).forEach(sec => sec.classList.remove('active'));
      sections[tab.dataset.tab].classList.add('active');
    });
  });

  // ==========================================================================
  // KALSHI CONTROLS
  // ==========================================================================
  const kalshiStartBtn = document.getElementById('kalshi-start-btn');
  const kalshiStatus = document.getElementById('kalshi-status');
  const kalshiBankroll = document.getElementById('kalshi-bankroll');

  kalshiStartBtn?.addEventListener('click', async () => {
    const wasRunning = state.kalshi.running;
    const endpoint = wasRunning ? '/api/stop' : '/api/start';
    
    // Show transitional state
    kalshiStartBtn.disabled = true;
    kalshiStartBtn.textContent = wasRunning ? 'Stopping...' : 'Starting...';
    kalshiStatus.textContent = wasRunning ? 'Stopping...' : 'Starting...';
    kalshiStatus.classList.remove('status-on', 'status-off');
    kalshiStatus.classList.add('status-pending');
    
    try {
      const res = await fetch(endpoint, { method: 'POST' });
      const data = await res.json();
      state.kalshi.running = data.running;
      if (data.stats) {
        state.stats = data.stats;
        state.kalshi.bankroll = data.stats.bankroll;
        state.kalshi.pnl = data.stats.total_pnl;
      }
      refreshKalshiStatus(wasRunning);
      updateStats(state.stats);
    } catch (err) {
      // Revert on error
      state.kalshi.running = wasRunning;
      refreshKalshiStatus();
    } finally {
      kalshiStartBtn.disabled = false;
    }
  });

  function refreshKalshiStatus(wasRunning = null) {
    kalshiStatus.textContent = state.kalshi.running ? "PRINTIN'" : 'Inactive';
    kalshiStatus.classList.remove('status-on', 'status-off', 'status-pending');
    kalshiStatus.classList.add(state.kalshi.running ? 'status-on' : 'status-off');
    kalshiStartBtn.textContent = state.kalshi.running ? 'Stop' : 'Start';
    kalshiStartBtn.classList.toggle('engine-active', state.kalshi.running);
    
    // Toggle gold tracer effect based on engine running state
    const tickerCard = document.getElementById('ticker-kalshi');
    tickerCard.classList.toggle('engine-running', state.kalshi.running);
    
    // Apply flicker effects on state change
    if (wasRunning !== null && wasRunning !== state.kalshi.running) {
      kalshiStartBtn.classList.remove('flicker-on', 'flicker-off');
      if (state.kalshi.running) {
        // Turned on - flicker on
        kalshiStartBtn.classList.add('flicker-on');
      } else {
        // Turned off - flicker off
        kalshiStartBtn.classList.add('flicker-off');
      }
      // Remove the class after animation completes
      setTimeout(() => {
        kalshiStartBtn.classList.remove('flicker-on', 'flicker-off');
      }, 600);
    }
  }

  // ==========================================================================
  // UPLINK BUTTON
  // ==========================================================================
  const uplinkBtn = document.getElementById('kalshi-uplink-btn');
  const uplinkStatusPill = document.getElementById('uplink-status-pill');
  const uplinkErrorMsg = document.getElementById('uplink-error-msg');

  function setUplinkBtnState(state) {
    if (!uplinkBtn) return;
    uplinkBtn.classList.remove('checking', 'connected', 'disconnected');
    if (state) uplinkBtn.classList.add(state);
  }

  uplinkBtn?.addEventListener('click', async () => {
    // Set checking state
    uplinkStatusPill.className = 'ticker-tag status-pill checking';
    uplinkStatusPill.textContent = 'Checking...';
    uplinkErrorMsg.textContent = '';
    setUplinkBtnState('checking');
    uplinkBtn.disabled = true;

    try {
      const res = await fetch('/api/uplink', { method: 'POST' });
      const data = await res.json();

      if (data.connected) {
        uplinkStatusPill.className = 'ticker-tag status-pill connected';
        uplinkStatusPill.textContent = 'Connected';
        uplinkErrorMsg.textContent = '';
        setUplinkBtnState('connected');
        // Add green border effect for uplink connected
        document.getElementById('ticker-kalshi').classList.add('uplink-connected');
        // Update balance if returned
        if (data.balance !== undefined) {
          state.kalshi.bankroll = data.balance;
          kalshiBankroll.textContent = `$${data.balance.toFixed(2)}`;
        }
        // Update P&L chart with real data
        if (data.pnl !== undefined) {
          updatePnlChart(data.pnl);
        }
      } else {
        uplinkStatusPill.className = 'ticker-tag status-pill disconnected';
        uplinkStatusPill.textContent = 'Disconnected';
        uplinkErrorMsg.textContent = data.error || 'Connection failed';
        setUplinkBtnState('disconnected');
        // Remove green border effect
        document.getElementById('ticker-kalshi').classList.remove('uplink-connected');
      }
    } catch (err) {
      uplinkStatusPill.className = 'ticker-tag status-pill disconnected';
      uplinkStatusPill.textContent = 'Error';
      uplinkErrorMsg.textContent = err.message || 'Network error';
      setUplinkBtnState('disconnected');
      // Remove green border effect
      document.getElementById('ticker-kalshi').classList.remove('uplink-connected');
    } finally {
      uplinkBtn.disabled = false;
    }
  });

  // ==========================================================================
  // STATS UPDATER
  // ==========================================================================
  function updateStats(stats) {
    state.stats = stats;
    state.kalshi.bankroll = stats.bankroll;
    state.kalshi.pnl = stats.total_pnl;

    // Update dashboard stats cards
    const rrEl = document.getElementById('stat-rr');
    rrEl.textContent = stats.trades > 0 ? stats.avg_rr.toFixed(2) : '--';
    document.getElementById('stat-trades').textContent = stats.trades;
    document.getElementById('stat-winrate').textContent = stats.trades > 0 ? `${stats.win_rate.toFixed(1)}%` : '--%';
    document.getElementById('stat-wins').textContent = stats.wins;
    document.getElementById('stat-losses').textContent = stats.losses;

    // Update Kalshi ticker
    kalshiBankroll.textContent = `$${state.kalshi.bankroll.toFixed(2)}`;

    // Update P&L chart
    updatePnlChart(stats.total_pnl);
  }

  // ==========================================================================
  // PERFORMANCE (7d) + BACKTESTING
  // ==========================================================================
  const perfCtx = document.getElementById('perf-chart')?.getContext('2d');
  let perfChart = null;

  function renderPerformanceChart(daily = []) {
    if (!perfCtx) return;
    const labels = daily.map(d => d.date?.slice(5) || '');
    const data = daily.map(d => d.pnl ?? 0);
    const bounds = computeScaleBounds(data.length ? data : [0]);
    const dataset = {
      label: 'Daily P&L',
      data,
      backgroundColor: data.map(v => (v >= 0 ? 'rgba(0, 200, 120, 0.35)' : 'rgba(255, 107, 107, 0.35)')),
      borderColor: data.map(v => (v >= 0 ? '#00c878' : '#ff6b6b')),
      borderWidth: 1.5,
    };
    if (!perfChart) {
      perfChart = new Chart(perfCtx, {
        type: 'bar',
        data: { labels, datasets: [dataset] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              suggestedMin: bounds.suggestedMin,
              suggestedMax: bounds.suggestedMax,
              grid: { color: 'rgba(255,255,255,0.05)' },
            },
            x: { grid: { display: false } },
          },
          plugins: { legend: { display: false } },
        },
      });
    } else {
      perfChart.data.labels = labels;
      perfChart.data.datasets[0].data = data;
      perfChart.options.scales.y.suggestedMin = bounds.suggestedMin;
      perfChart.options.scales.y.suggestedMax = bounds.suggestedMax;
      perfChart.update();
    }
  }

  function renderPerformanceHistory(rows = []) {
    const body = document.getElementById('perf-history-body');
    if (!body) return;
    body.innerHTML = '';
    if (!rows.length) {
      body.innerHTML = '<tr><td colspan="7" class="muted">No trades yet.</td></tr>';
      return;
    }
    rows.forEach((row) => {
      const pnlClass = row.pnl > 0 ? 'pnl-positive' : row.pnl < 0 ? 'pnl-negative' : '';
      const resultClass = row.pnl > 0 ? 'badge-win' : row.pnl < 0 ? 'badge-loss' : 'badge-pending';
      const ts = row.ts ? new Date(row.ts * 1000).toLocaleString() : '--';
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${ts}</td>
        <td>${row.matchup || '--'}</td>
        <td>${row.team || '--'}</td>
        <td>${(row.edge || 0).toFixed(2)}%</td>
        <td>$${Number(row.stake || 0).toFixed(2)}</td>
        <td><span class="badge ${resultClass}">${row.result || 'PENDING'}</span></td>
        <td class="${pnlClass}">${row.pnl >= 0 ? '+' : ''}${Number(row.pnl || 0).toFixed(2)}</td>
      `;
      body.appendChild(tr);
    });
  }

  function updatePerformanceUI(payload, source) {
    state.performance.source = source;
    state.performance.metrics = payload.metrics;
    state.performance.history = payload.history;
    const m = payload.metrics || {};
    document.getElementById('perf-pnl').textContent = fmt.currency(m.pnl);
    document.getElementById('perf-winrate').textContent = fmt.pct(m.win_rate);
    document.getElementById('perf-roi').textContent = fmt.pct(m.roi);
    document.getElementById('perf-edge').textContent = `${Number(m.avg_edge || 0).toFixed(2)}%`;
    document.getElementById('perf-chart-pnl').textContent = fmt.currency(m.pnl);
    document.getElementById('perf-trade-count').textContent = `${m.trades || 0} trades`;
    renderPerformanceChart(m.daily || []);
    renderPerformanceHistory(payload.history || []);
  }

  async function fetchPerformance(source = 'paper') {
    const res = await fetch(`/api/performance?source=${source}`);
    const data = await res.json();
    updatePerformanceUI(data, source);
    document.querySelectorAll('#performance-source-toggle .pill-btn').forEach((btn) => {
      btn.classList.toggle('active', btn.dataset.source === source);
    });
  }

  // Backtest UI helpers
  function clearBacktestData() {
    // Clear summary
    updateBacktestSummary({});
    
    // Clear chart
    if (backtestChart) {
      backtestChart.data.labels = [];
      backtestChart.data.datasets[0].data = [];
      backtestChart.update();
    }
    document.getElementById('backtest-chart-pnl').textContent = '$0.00';
    
    // Clear trades table
    const tradesBody = document.getElementById('backtest-trades-body');
    if (tradesBody) {
      tradesBody.innerHTML = '<tr><td colspan="7" class="muted">No trades yet. Run a backtest to see results.</td></tr>';
    }
    
    // Clear status
    hideBacktestStatus();
  }

  function updateBacktestSummary(summary = {}) {
    document.getElementById('bt-trades').textContent = summary.trades ?? '--';
    document.getElementById('bt-winrate').textContent = summary.win_rate !== undefined ? fmt.pct(summary.win_rate) : '--';
    document.getElementById('bt-pnl').textContent = summary.pnl !== undefined ? fmt.currency(summary.pnl) : '--';
    document.getElementById('bt-roi').textContent = summary.roi !== undefined ? fmt.pct(summary.roi) : '--';
    document.getElementById('bt-ending-balance').textContent = summary.ending_balance !== undefined ? fmt.currency(summary.ending_balance) : '--';
    document.getElementById('bt-dd').textContent = summary.max_drawdown !== undefined ? fmt.currency(summary.max_drawdown) : '--';
  }

  function renderBacktestTrades(trades = []) {
    const body = document.getElementById('backtest-trades-body');
    if (!body) return;
    
    body.innerHTML = '';
    if (!trades.length) {
      body.innerHTML = '<tr><td colspan="7" class="muted">No trades yet. Run a backtest to see results.</td></tr>';
      return;
    }
    
    // Sort trades by timestamp
    const sortedTrades = [...trades].sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
    
    sortedTrades.forEach((trade) => {
      const tr = document.createElement('tr');
      const date = trade.timestamp ? new Date(trade.timestamp * 1000).toLocaleString() : '--';
      const resultClass = trade.result === 'WIN' ? 'positive' : trade.result === 'LOSS' ? 'negative' : '';
      const pnlClass = trade.pnl >= 0 ? 'positive' : 'negative';
      
      tr.innerHTML = `
        <td>${date}</td>
        <td>${trade.sport || '--'}</td>
        <td>${trade.matchup || '--'}</td>
        <td>${trade.team || '--'}</td>
        <td>${trade.edge !== undefined ? fmt.pct(trade.edge / 100) : '--'}</td>
        <td>${trade.stake !== undefined ? fmt.currency(trade.stake) : '--'}</td>
        <td class="${resultClass}">${trade.result || '--'}</td>
        <td class="${pnlClass}">${trade.pnl !== undefined ? fmt.currency(trade.pnl) : '--'}</td>
      `;
      body.appendChild(tr);
    });
  }

  function renderBacktestHistory(rows = []) {
    const body = document.getElementById('backtest-history-body');
    body.innerHTML = '';
    if (!rows.length) {
      body.innerHTML = '<tr><td colspan="6" class="muted">No backtests yet.</td></tr>';
      return;
    }
    rows.forEach((row) => {
      const summary = row.summary || {};
      const tr = document.createElement('tr');
      const created = row.created_at ? new Date(row.created_at * 1000).toLocaleString() : '--';
      tr.innerHTML = `
        <td>${created}</td>
        <td>${row.sports}</td>
        <td>${row.start_date} → ${row.end_date}</td>
        <td>${summary.pnl !== undefined ? fmt.currency(summary.pnl) : '--'}</td>
        <td>${summary.win_rate !== undefined ? fmt.pct(summary.win_rate) : '--'}</td>
        <td>${summary.roi !== undefined ? fmt.pct(summary.roi) : '--'}</td>
      `;
      body.appendChild(tr);
    });
  }

  async function refreshBacktestHistory() {
    const res = await fetch('/api/backtest/history');
    const rows = await res.json();
    renderBacktestHistory(rows);
  }

  function updateBacktestStatus(type, message, progress = null) {
    const status = document.getElementById('backtest-status');
    if (!status) return;
    
    status.className = 'backtest-status visible ' + type;
    
    if (type === 'running' && progress !== null) {
      status.innerHTML = `
        <div class="spinner"></div>
        <span>${message}</span>
        <div class="progress-bar">
          <div class="progress-bar-fill" style="width: ${progress}%"></div>
        </div>
        <span>${progress}%</span>
      `;
    } else if (type === 'running') {
      status.innerHTML = `<div class="spinner"></div><span>${message}</span>`;
    } else {
      status.innerHTML = `<span>${message}</span>`;
    }
  }

  function hideBacktestStatus() {
    const status = document.getElementById('backtest-status');
    if (status) {
      status.className = 'backtest-status';
    }
  }

  async function runBacktest(payload) {
    const btn = document.getElementById('backtest-run-btn');
    const panel = document.getElementById('backtest-panel');
    const wasRunning = btn.classList.contains('engine-active');
    
    btn.disabled = true;
    btn.textContent = 'Running...';
    btn.classList.add('engine-active');
    panel?.classList.add('engine-running');
    
    // Add flicker effect
    btn.classList.remove('flicker-on', 'flicker-off');
    btn.classList.add('flicker-on');
    setTimeout(() => btn.classList.remove('flicker-on'), 600);
    
      // Clear all previous data (one-session persistent)
      clearBacktestData();
      
      updateBacktestStatus('running', 'Initializing backtest...');
      
      try {
      // Validate dates
      const startDate = new Date(payload.start_date);
      const endDate = new Date(payload.end_date);
      const today = new Date();
      
      if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
        throw new Error('Invalid date format. Use YYYY-MM-DD.');
      }
      
      if (startDate > today || endDate > today) {
        throw new Error('Dates must be in the past. ESPN only has historical data.');
      }
      
      if (startDate > endDate) {
        throw new Error('Start date must be before end date.');
      }
      
      updateBacktestStatus('running', `Fetching ${payload.sports.join(', ')} games from ESPN...`, 10);
      
      const res = await fetch('/api/backtest', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      
      updateBacktestStatus('running', 'Processing response...', 70);
      
      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(`Server error (${res.status}): ${errorText}`);
      }
      
      const data = await res.json();
      
      if (data.error) {
        throw new Error(data.error);
      }
      
      updateBacktestStatus('running', 'Updating results...', 90);
      
      updateBacktestSummary(data.summary || {});
      
      // Render individual trades instead of history
      renderBacktestTrades(data.trades || []);
      
      // Update chart with backtest data
      updateBacktestChart(data.trades || [], payload.starting_balance || 1000);
      
      const trades = data.trades?.length || 0;
      const pnl = data.summary?.pnl?.toFixed(2) || '0.00';
      updateBacktestStatus('success', `✓ Backtest complete: ${trades} trades, $${pnl} P&L`);
      
      // Auto-hide success message after 5 seconds
      setTimeout(hideBacktestStatus, 5000);
      
    } catch (err) {
      console.error('Backtest error:', err);
      updateBacktestStatus('error', `✗ ${err.message}`);
    } finally {
      btn.disabled = false;
      btn.textContent = 'Run Backtest';
      btn.classList.remove('engine-active');
      panel?.classList.remove('engine-running');
      
      // Add flicker-off effect
      btn.classList.remove('flicker-on', 'flicker-off');
      btn.classList.add('flicker-off');
      setTimeout(() => btn.classList.remove('flicker-off'), 600);
    }
  }

  // Backtest chart
  let backtestChart = null;
  
  function initBacktestChart() {
    const ctx = document.getElementById('backtest-chart');
    if (!ctx) return;
    
    backtestChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'Cumulative P&L',
          data: [],
          borderColor: '#d4af37',
          backgroundColor: 'rgba(212, 175, 55, 0.1)',
          borderWidth: 2,
          fill: true,
          tension: 0.4,
          pointRadius: 0,
          pointHoverRadius: 4,
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            mode: 'index',
            intersect: false,
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            titleColor: '#d4af37',
            bodyColor: '#e8e8e8',
            borderColor: '#d4af37',
            borderWidth: 1,
            callbacks: {
              label: function(context) {
                return `P&L: ${fmt.currency(context.parsed.y)}`;
              }
            }
          }
        },
        scales: {
          x: {
            grid: {
              color: 'rgba(212, 175, 55, 0.1)',
              borderColor: 'rgba(212, 175, 55, 0.2)'
            },
            ticks: {
              color: '#d4af37',
              font: {
                family: 'Advent Pro',
                style: 'italic'
              }
            }
          },
          y: {
            beginAtZero: false,
            grid: {
              color: 'rgba(212, 175, 55, 0.1)',
              borderColor: 'rgba(212, 175, 55, 0.2)'
            },
            ticks: {
              color: '#d4af37',
              font: {
                family: 'Advent Pro',
                style: 'italic'
              },
              callback: function(value) {
                return fmt.currency(value);
              }
            }
          }
        }
      }
    });
  }
  
  function updateBacktestChart(trades, startingBalance) {
    if (!backtestChart) {
      console.error('Backtest chart not initialized');
      return;
    }
    
    if (!trades || !trades.length) {
      // Clear chart if no data
      backtestChart.data.labels = [];
      backtestChart.data.datasets[0].data = [];
      backtestChart.options.scales.y.min = undefined;
      backtestChart.options.scales.y.max = undefined;
      backtestChart.update();
      const pnlEl = document.getElementById('backtest-chart-pnl');
      if (pnlEl) pnlEl.textContent = '$0.00';
      return;
    }
    
    // Sort trades by timestamp
    const sortedTrades = [...trades].sort((a, b) => {
      const tsA = a.timestamp || 0;
      const tsB = b.timestamp || 0;
      return tsA - tsB;
    });
    
    // Calculate cumulative balance
    let cumulativeBalance = startingBalance || 1000;
    const labels = [];
    const data = [cumulativeBalance]; // Start with initial balance
    
    // Add initial point with start date (if available from form)
    const startDateInput = document.getElementById('backtest-start');
    if (startDateInput?.value) {
      try {
        const startDate = new Date(startDateInput.value);
        labels.push(startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
      } catch (e) {
        labels.push('Start');
      }
    } else {
      labels.push('Start');
    }
    
    sortedTrades.forEach((trade) => {
      cumulativeBalance += parseFloat(trade.pnl || 0);
      try {
        const timestamp = trade.timestamp ? (trade.timestamp * 1000) : Date.now();
        const date = new Date(timestamp);
        labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
      } catch (e) {
        labels.push('Trade');
      }
      data.push(cumulativeBalance);
    });
    
    // Calculate min/max for auto-scaling with 10% padding
    const minValue = Math.min(...data);
    const maxValue = Math.max(...data);
    const range = maxValue - minValue;
    const padding = Math.max(range * 0.1, Math.abs(minValue) * 0.1, 50);
    
    // Update chart with auto-scaled Y-axis
    backtestChart.data.labels = labels;
    backtestChart.data.datasets[0].data = data;
    
    // Set min/max with proper handling
    if (minValue !== Infinity && maxValue !== -Infinity) {
      backtestChart.options.scales.y.min = minValue - padding;
      backtestChart.options.scales.y.max = maxValue + padding;
    }
    
    backtestChart.update('active');
    
    // Update chart header value (final balance)
    const finalBalance = data[data.length - 1];
    const pnlEl = document.getElementById('backtest-chart-pnl');
    if (pnlEl) pnlEl.textContent = fmt.currency(finalBalance);
  }

  // iOS 26 Style Calendar Picker
  let currentPickerInput = null;
  let startCalendarDate = new Date();
  let endCalendarDate = new Date();
  let selectedStartDate = null;
  let selectedEndDate = null;

  function initCalendarPicker() {
    const overlay = document.getElementById('calendar-picker-overlay');
    const confirmBtn = document.getElementById('calendar-confirm');
    const cancelBtn = document.getElementById('calendar-cancel');
    const closeBtn = document.getElementById('calendar-close');
    
    // Calendar elements
    const startDaysContainer = document.getElementById('start-calendar-days');
    const endDaysContainer = document.getElementById('end-calendar-days');
    const startMonthYear = document.getElementById('start-month-year');
    const endMonthYear = document.getElementById('end-month-year');
    const startPrevBtn = document.getElementById('start-prev-month');
    const startNextBtn = document.getElementById('start-next-month');
    const endPrevBtn = document.getElementById('end-prev-month');
    const endNextBtn = document.getElementById('end-next-month');

    // Render calendar grid
    function renderCalendar(container, monthYear, selectedDate, onDateSelect) {
      container.innerHTML = '';
      const [year, month] = monthYear;
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      const startDayOfWeek = firstDay.getDay();
      const daysInMonth = lastDay.getDate();
      const today = new Date();
      const oneYearAgo = new Date();
      oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
      
      // Add empty cells for days before month starts
      for (let i = 0; i < startDayOfWeek; i++) {
        const empty = document.createElement('div');
        empty.className = 'calendar-day other-month';
        container.appendChild(empty);
      }
      
      // Add days of the month
      for (let day = 1; day <= daysInMonth; day++) {
        const dayEl = document.createElement('div');
        dayEl.className = 'calendar-day';
        dayEl.textContent = day;
        dayEl.dataset.day = day;
        dayEl.dataset.month = month;
        dayEl.dataset.year = year;
        
        const cellDate = new Date(year, month, day);
        const isToday = cellDate.toDateString() === today.toDateString();
        const isSelected = selectedDate && 
          cellDate.getFullYear() === selectedDate.getFullYear() &&
          cellDate.getMonth() === selectedDate.getMonth() &&
          cellDate.getDate() === selectedDate.getDate();
        const isValid = cellDate >= oneYearAgo && cellDate <= today;
        
        if (!isValid) {
          dayEl.classList.add('other-month');
          dayEl.style.pointerEvents = 'none';
        } else {
          if (isToday) dayEl.classList.add('today');
          if (isSelected) dayEl.classList.add('selected');
          
          dayEl.addEventListener('click', () => {
            const date = new Date(year, month, day);
            onDateSelect(date);
            renderCalendar(container, monthYear, date, onDateSelect);
          });
        }
        
        container.appendChild(dayEl);
      }
    }

    // Update month/year display
    function updateMonthYear(monthYearEl, year, month) {
      const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                     'July', 'August', 'September', 'October', 'November', 'December'];
      monthYearEl.textContent = `${months[month]} ${year}`;
    }

    // Check if date is within 1 year back
    function isDateValid(date) {
      const today = new Date();
      const oneYearAgo = new Date(today.getFullYear() - 1, today.getMonth(), today.getDate());
      return date >= oneYearAgo && date <= today;
    }

    // Navigation handlers
    startPrevBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const newDate = new Date(startCalendarDate);
      newDate.setMonth(newDate.getMonth() - 1);
      const oneYearAgo = new Date();
      oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
      if (newDate >= oneYearAgo) {
        startCalendarDate = newDate;
        updateMonthYear(startMonthYear, startCalendarDate.getFullYear(), startCalendarDate.getMonth());
        renderCalendar(startDaysContainer, 
          [startCalendarDate.getFullYear(), startCalendarDate.getMonth()], 
          selectedStartDate, 
          (date) => { 
            if (isDateValid(date)) selectedStartDate = date; 
          });
      }
    });

    startNextBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const newDate = new Date(startCalendarDate);
      newDate.setMonth(newDate.getMonth() + 1);
      const today = new Date();
      if (newDate <= today) {
        startCalendarDate = newDate;
        updateMonthYear(startMonthYear, startCalendarDate.getFullYear(), startCalendarDate.getMonth());
        renderCalendar(startDaysContainer, 
          [startCalendarDate.getFullYear(), startCalendarDate.getMonth()], 
          selectedStartDate, 
          (date) => { 
            if (isDateValid(date)) selectedStartDate = date; 
          });
      }
    });

    endPrevBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const newDate = new Date(endCalendarDate);
      newDate.setMonth(newDate.getMonth() - 1);
      const oneYearAgo = new Date();
      oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
      if (newDate >= oneYearAgo) {
        endCalendarDate = newDate;
        updateMonthYear(endMonthYear, endCalendarDate.getFullYear(), endCalendarDate.getMonth());
        renderCalendar(endDaysContainer, 
          [endCalendarDate.getFullYear(), endCalendarDate.getMonth()], 
          selectedEndDate, 
          (date) => { 
            if (isDateValid(date)) selectedEndDate = date; 
          });
      }
    });

    endNextBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const newDate = new Date(endCalendarDate);
      newDate.setMonth(newDate.getMonth() + 1);
      const today = new Date();
      if (newDate <= today) {
        endCalendarDate = newDate;
        updateMonthYear(endMonthYear, endCalendarDate.getFullYear(), endCalendarDate.getMonth());
        renderCalendar(endDaysContainer, 
          [endCalendarDate.getFullYear(), endCalendarDate.getMonth()], 
          selectedEndDate, 
          (date) => { 
            if (isDateValid(date)) selectedEndDate = date; 
          });
      }
    });

    // Open calendar
    function openCalendar(inputEl) {
      currentPickerInput = inputEl;
      
      // Find the form-control parent
      const formControl = inputEl.closest('.form-control');
      if (formControl) {
        // Move overlay to form-control if not already there
        if (overlay.parentElement !== formControl) {
          formControl.appendChild(overlay);
        }
      }
      
      // Get current values from the separate inputs
      const startInput = document.getElementById('backtest-start');
      const endInput = document.getElementById('backtest-end');
      const startValue = startInput?.value || '';
      const endValue = endInput?.value || '';
      
      // Parse start date
      if (startValue) {
        const date = new Date(startValue);
        if (!isNaN(date.getTime())) {
          selectedStartDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
          startCalendarDate = new Date(date.getFullYear(), date.getMonth(), 1);
        }
      } else {
        // Default to 30 days ago
        const defaultDate = new Date(Date.now() - 30 * 86400000);
        selectedStartDate = new Date(defaultDate.getFullYear(), defaultDate.getMonth(), defaultDate.getDate());
        startCalendarDate = new Date(defaultDate.getFullYear(), defaultDate.getMonth(), 1);
      }
      
      // Parse end date
      if (endValue) {
        const date = new Date(endValue);
        if (!isNaN(date.getTime())) {
          selectedEndDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
          endCalendarDate = new Date(date.getFullYear(), date.getMonth(), 1);
        }
      } else {
        // Default to 7 days ago
        const defaultDate = new Date(Date.now() - 7 * 86400000);
        selectedEndDate = new Date(defaultDate.getFullYear(), defaultDate.getMonth(), defaultDate.getDate());
        endCalendarDate = new Date(defaultDate.getFullYear(), defaultDate.getMonth(), 1);
      }

      // Render both calendars
      updateMonthYear(startMonthYear, startCalendarDate.getFullYear(), startCalendarDate.getMonth());
      updateMonthYear(endMonthYear, endCalendarDate.getFullYear(), endCalendarDate.getMonth());
      
      renderCalendar(startDaysContainer, 
        [startCalendarDate.getFullYear(), startCalendarDate.getMonth()], 
        selectedStartDate, 
        (date) => { selectedStartDate = date; });
      
      renderCalendar(endDaysContainer, 
        [endCalendarDate.getFullYear(), endCalendarDate.getMonth()], 
        selectedEndDate, 
        (date) => { selectedEndDate = date; });

      overlay.classList.add('visible');
    }

    // Close calendar
    function closeCalendar() {
      overlay.classList.remove('visible');
      currentPickerInput = null;
      // Move overlay back to body when closed
      if (overlay.parentElement && overlay.parentElement !== document.body) {
        document.body.appendChild(overlay);
      }
    }

    // Confirm selection
    confirmBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      if (!selectedStartDate || !selectedEndDate) {
        return;
      }
      
      const startFormatted = selectedStartDate.toISOString().slice(0, 10);
      const endFormatted = selectedEndDate.toISOString().slice(0, 10);
      
      // Get current values to check if they changed
      const startInput = document.getElementById('backtest-start');
      const endInput = document.getElementById('backtest-end');
      const dateChanged = startInput?.value !== startFormatted || endInput?.value !== endFormatted;
      
      // Update the hidden inputs (without triggering events)
      if (startInput) {
        startInput.value = startFormatted;
      }
      if (endInput) {
        endInput.value = endFormatted;
      }
      
      // Update the date range display field
      if (currentPickerInput) {
        currentPickerInput.value = `${startFormatted} → ${endFormatted}`;
      }
      
      // Clear all backtest data if date range changed
      if (dateChanged) {
        clearBacktestData();
      }
      
      closeCalendar();
    });

    // Cancel/Close
    cancelBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeCalendar();
    });
    closeBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeCalendar();
    });
    
    // Close when clicking outside
    document.addEventListener('click', (e) => {
      if (overlay.classList.contains('visible')) {
        const clickedInside = overlay.contains(e.target) || 
                              (currentPickerInput && currentPickerInput.contains(e.target));
        if (!clickedInside) {
          closeCalendar();
        }
      }
    });

    // Attach to date range input
    const dateRangeInput = document.getElementById('backtest-date-range');
    if (dateRangeInput) {
      dateRangeInput.addEventListener('click', () => openCalendar(dateRangeInput));
    }
    
    // Also attach to old date inputs for backward compatibility
    document.querySelectorAll('.date-picker-input').forEach(input => {
      if (input.id !== 'backtest-date-range') {
        input.addEventListener('click', () => openCalendar(input));
      }
    });
  }

  function initPerformance() {
    // Initialize calendar picker
    initCalendarPicker();

    // Default to 30 days ago to 7 days ago (historical data ESPN has)
    const thirtyDaysAgo = new Date(Date.now() - 30 * 86400000).toISOString().slice(0, 10);
    const sevenDaysAgo = new Date(Date.now() - 7 * 86400000).toISOString().slice(0, 10);
    const startInput = document.getElementById('backtest-start');
    const endInput = document.getElementById('backtest-end');
    const rangeInput = document.getElementById('backtest-date-range');
    
    if (startInput) startInput.value = thirtyDaysAgo;
    if (endInput) endInput.value = sevenDaysAgo;
    if (rangeInput) rangeInput.value = `${thirtyDaysAgo} → ${sevenDaysAgo}`;
    
    document.getElementById('backtest-sports').value = (state.config.sports || []).join(',');

    document.querySelectorAll('#performance-source-toggle .pill-btn').forEach((btn) => {
      btn.addEventListener('click', () => fetchPerformance(btn.dataset.source));
    });

    // Reset Log button
    const resetBtn = document.getElementById('backtest-reset-btn');
    resetBtn?.addEventListener('click', () => {
      clearBacktestData();
    });

    // Function to get backtest payload
    function getBacktestPayload() {
      const sports = (document.getElementById('backtest-sports').value || '').split(',').map(s => s.trim()).filter(Boolean);
      return {
        sports: sports.length ? sports : state.config.sports,
        start_date: document.getElementById('backtest-start').value,
        end_date: document.getElementById('backtest-end').value,
        stake: parseFloat(document.getElementById('backtest-stake').value || '10'),
        edge_threshold: parseFloat(document.getElementById('backtest-edge').value || '0.05'),
        starting_balance: parseFloat(document.getElementById('backtest-starting-balance').value || '1000'),
      };
    }

    // Run Backtest button
    const runBtn = document.getElementById('backtest-run-btn');
    runBtn?.addEventListener('click', () => {
      const payload = getBacktestPayload();
      runBacktest(payload);
    });

    // Form submit handler (for Enter key)
    const backtestForm = document.getElementById('backtest-form');
    backtestForm?.addEventListener('submit', (e) => {
      e.preventDefault();
      const payload = getBacktestPayload();
      runBacktest(payload);
    });

    // Initialize chart
    initBacktestChart();

    fetchPerformance('paper');
  }

  // ==========================================================================
  // CONFIG FORM
  // ==========================================================================
  const configForm = document.getElementById('config-form');
  const resetBtn = document.getElementById('reset-config');

  configForm?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const formData = new FormData(configForm);
    const payload = {};
    formData.forEach((v, k) => payload[k] = v);
    payload.kelly_multiplier = parseFloat(payload.kelly_multiplier);
    payload.target_buy_ev = parseFloat(payload.target_buy_ev);
    payload.target_sell_ev = parseFloat(payload.target_sell_ev);
    payload.max_percentage_bet = parseFloat(payload.max_percentage_bet);
    payload.max_dollar_bet = parseFloat(payload.max_dollar_bet);
    payload.min_true_prob = parseFloat(payload.min_true_prob);
    payload.max_true_prob = parseFloat(payload.max_true_prob);
    payload.trading_start = parseInt(payload.trading_start, 10);
    payload.trading_end = parseInt(payload.trading_end, 10);
    payload.sports = (payload.sports || '').split(',').map(s => s.trim()).filter(Boolean);
    payload.boltodds_api_key = payload.boltodds_api_key || '';

    const res = await fetch('/api/config', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    const data = await res.json();
    state.config = data.config;
    appendLog('[Config] Settings saved successfully');
  });

  resetBtn?.addEventListener('click', () => {
    configForm.reset();
    // Reset sport chips to default
    document.querySelectorAll('.sport-chip').forEach(chip => {
      const defaultSports = ['NBA', 'NFL', 'NHL'];
      chip.classList.toggle('active', defaultSports.includes(chip.dataset.sport));
    });
    updateSportsInput();
  });

  // Sport Chips Handler
  const sportChips = document.querySelectorAll('.sport-chip');
  const sportsInput = document.getElementById('sports-input');

  function updateSportsInput() {
    const activeSports = Array.from(document.querySelectorAll('.sport-chip.active'))
      .map(chip => chip.dataset.sport);
    sportsInput.value = activeSports.join(',');
  }

  sportChips.forEach(chip => {
    chip.addEventListener('click', () => {
      chip.classList.toggle('active');
      updateSportsInput();
    });
  });

  // ==========================================================================
  // SSE STREAMS
  // ==========================================================================
  const logArea = document.getElementById('log-area');
  const oppBody = document.getElementById('opportunities-body');
  const tradesBody = document.getElementById('trades-body');
  const oppSearch = document.getElementById('opp-search');
  const oppSort = document.getElementById('opp-sort');
  const oppSportFilter = document.getElementById('opp-sport-filter');

  function appendLog(line) {
    const div = document.createElement('div');
    div.textContent = line;
    logArea.appendChild(div);
    logArea.scrollTop = logArea.scrollHeight;
  }

  document.getElementById('clear-logs')?.addEventListener('click', () => {
    logArea.innerHTML = '';
  });

  function renderOpportunities() {
    const searchTerm = (oppSearch?.value || '').toLowerCase();
    const sportFilter = (oppSportFilter?.value || '').toLowerCase();
    const sortKey = oppSort?.value || 'timestamp';

    const filtered = state.opportunities
      .filter((opp) => {
        const matchesSearch = opp.matchup.toLowerCase().includes(searchTerm) || opp.team.toLowerCase().includes(searchTerm);
        const matchesSport = !sportFilter || (opp.sport || '').toLowerCase() === sportFilter;
        return matchesSearch && matchesSport;
      })
      .sort((a, b) => {
        if (sortKey === 'edge') return b.edge - a.edge;
        if (sortKey === 'stake') return (b.kelly_stake || 0) - (a.kelly_stake || 0);
        return (b.timestamp || 0) - (a.timestamp || 0);
      });

    // Render to all kanban containers (dashboard + opportunities tab)
    document.querySelectorAll('.opportunities-kanban').forEach(kanban => {
      kanban.innerHTML = '';
      if (!filtered.length) {
        kanban.innerHTML = '<div class="opp-empty-state"><span class="muted">No opportunities match the filters.</span></div>';
        return;
      }

      filtered.slice(0, 20).forEach((opp) => {
        const stake = Number(opp.kelly_stake ?? 0);
        const pppOdds = Number(opp.true_prob ?? 0);
        const mktOdds = Number(opp.market_prob ?? 0);
        const edge = Number(opp.edge ?? 0);
        const ts = opp.timestamp ? new Date(opp.timestamp * 1000).toLocaleTimeString() : '--';
        const isPositive = edge > 0;
        
        const row = document.createElement('div');
        row.className = `opp-row ${isPositive ? 'positive' : 'negative'}`;
        row.dataset.matchup = opp.matchup;
        
        // Determine pill classes based on values
        const edgePillClass = edge > 0 ? 'pill-positive' : edge < 0 ? 'pill-negative' : 'pill-neutral';
        const pppPillClass = pppOdds > mktOdds ? 'pill-positive' : pppOdds < mktOdds ? 'pill-negative' : 'pill-neutral';
        const mktPillClass = 'pill-neutral';
        const stakePillClass = stake > 0 ? 'pill-positive' : 'pill-neutral';
        
        row.innerHTML = `
          <div class="opp-cell">
            <span class="opp-label">Matchup</span>
            <span class="opp-matchup">${opp.matchup}</span>
          </div>
          <div class="opp-cell">
            <span class="opp-label">Position</span>
            <span class="opp-position">${opp.team}</span>
          </div>
          <div class="opp-cell">
            <span class="opp-label">PPP Odds</span>
            <span class="${pppPillClass}">${(pppOdds * 100).toFixed(1)}%</span>
          </div>
          <div class="opp-cell">
            <span class="opp-label">MKT Odds</span>
            <span class="${mktPillClass}">${(mktOdds * 100).toFixed(1)}%</span>
          </div>
          <div class="opp-cell">
            <span class="opp-label">Edge</span>
            <span class="${edgePillClass}">${edge >= 0 ? '+' : ''}${edge.toFixed(2)}%</span>
          </div>
          <div class="opp-cell">
            <span class="opp-label">Stake</span>
            <span class="${stakePillClass}">$${stake.toFixed(2)}</span>
          </div>
          <div class="opp-cell">
            <span class="opp-timestamp">${ts}</span>
          </div>
        `;
        kanban.appendChild(row);
      });
    });
  }

  oppSearch?.addEventListener('input', renderOpportunities);
  oppSort?.addEventListener('change', renderOpportunities);
  oppSportFilter?.addEventListener('change', renderOpportunities);

  function addOpportunity(opp) {
    state.oppCount += 1;
    
    // Check if this matchup already exists (for flicker effect)
    const existingIdx = state.opportunities.findIndex(o => o.matchup === opp.matchup && o.team === opp.team);
    const isUpdate = existingIdx !== -1;
    
    if (isUpdate) {
      // Remove old entry
      state.opportunities.splice(existingIdx, 1);
    }
    
    state.opportunities.unshift(opp);
    if (state.opportunities.length > 200) {
      state.opportunities.pop();
    }
    renderOpportunities();
    
    // Add flicker effect for updates
    if (isUpdate) {
      const kanban = document.getElementById('opportunities-kanban');
      const row = kanban?.querySelector(`[data-matchup="${opp.matchup}"]`);
      if (row) {
        row.classList.add('flicker-update');
        setTimeout(() => row.classList.remove('flicker-update'), 600);
      }
    }
  }

  function addTrade(trade) {
    // Add to all trade tables (dashboard split + trades tab)
    document.querySelectorAll('#trades-body').forEach(tradesBody => {
      const tr = document.createElement('tr');
      tr.className = `trade-row ${trade.result === 'WIN' ? 'win' : 'loss'}`;
      const pnlClass = trade.pnl > 0 ? 'pnl-positive' : trade.pnl < 0 ? 'pnl-negative' : '';
      const badgeClass = trade.result === 'WIN' ? 'badge-win' : trade.result === 'LOSS' ? 'badge-loss' : 'badge-pending';
      tr.innerHTML = `
        <td>${new Date(trade.timestamp * 1000).toLocaleTimeString()}</td>
        <td>${trade.matchup}</td>
        <td>${trade.team}</td>
        <td>${(trade.entry_price * 100).toFixed(1)}%</td>
        <td>$${trade.stake.toFixed(2)}</td>
        <td>${trade.edge.toFixed(2)}%</td>
        <td><span class="badge ${badgeClass}">${trade.result}</span></td>
        <td class="${pnlClass}">${trade.pnl >= 0 ? '+' : ''}${trade.pnl.toFixed(2)}</td>
      `;
      if (tradesBody.children.length === 1 && tradesBody.children[0].querySelector('.muted')) {
        tradesBody.innerHTML = '';
      }
      tradesBody.prepend(tr);
      while (tradesBody.children.length > 50) {
        tradesBody.removeChild(tradesBody.lastChild);
      }
    });
  }

  // Log stream
  const logStream = new EventSource('/stream/logs');
  logStream.onmessage = (event) => {
    const data = JSON.parse(event.data);
    appendLog(data.log);
  };

  // Opportunity stream
  const oppStream = new EventSource('/stream/opportunities');
  oppStream.onmessage = (event) => {
    const data = JSON.parse(event.data);
    addOpportunity(data);
  };

  // Trades stream
  const tradeStream = new EventSource('/stream/trades');
  tradeStream.onmessage = (event) => {
    const trade = JSON.parse(event.data);
    addTrade(trade);
    fetch('/api/stats')
      .then(r => r.json())
      .then(stats => updateStats(stats));
  };

  // Periodic stats refresh for live Kalshi balance/P&L
  setInterval(() => {
    fetch('/api/stats')
      .then(r => r.json())
      .then(stats => updateStats(stats))
      .catch(() => { });
  }, 10000);

  // Initial render
  refreshKalshiStatus();
  updateStats(state.stats);
  renderOpportunities();
  initPerformance();
</script>
{% endblock %}