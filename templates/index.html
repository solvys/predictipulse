{% extends "base.html" %}

{% block content %}
<div class="app-shell">
  <div class="main-area">
    {% include "components/header.html" %}

    <div class="tabs">
      <button class="tab active" data-tab="dashboard">Dashboard</button>
      <button class="tab" data-tab="trades">Trades</button>
      <button class="tab" data-tab="config">Config</button>
      <button class="tab" data-tab="logs">Logs</button>
    </div>

    <div class="tab-section active" id="tab-dashboard">
      {% include "components/stats_cards.html" %}
      {% include "components/opportunities.html" %}
    </div>

    <div class="tab-section" id="tab-trades">
      {% include "components/trades_table.html" %}
    </div>

    <div class="tab-section" id="tab-config">
      {% include "components/config_panel.html" %}
    </div>

    <div class="tab-section" id="tab-logs">
      {% include "components/log_viewer.html" %}
    </div>
  </div>
</div>

<script>
  // ==========================================================================
  // STATE
  // ==========================================================================
  const state = {
    kalshi: {
      running: {{ 'true' if running else 'false' }},
      bankroll: {{ stats.bankroll }},
      pnl: {{ stats.total_pnl }},
    },
    config: {{ config | tojson }},
    stats: {{ stats | tojson }},
    oppCount: 0,
    currentPeriod: 'day',
    opportunities: [],
  };

  // ==========================================================================
  // TIME-BASED CHART DATA GENERATION
  // ==========================================================================
  // 24h view: 12 PM (noon) -> 5 PM -> 12 AM (midnight) - 12 hour span
  // Data points every 30 mins = 25 points total
  function generate24hData() {
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();

    // Convert current time to position in 12-hour span (12 PM = 0, 12 AM = 12)
    let hoursFromNoon;
    if (currentHour >= 12) {
      hoursFromNoon = currentHour - 12 + currentMinute / 60;
    } else {
      hoursFromNoon = currentHour + 12 + currentMinute / 60; // past midnight
    }

    const labels = [];
    const data = [];
    const totalPoints = 25; // 0 to 24 = 25 points for 12 hours (every 30 min)

    for (let i = 0; i < totalPoints; i++) {
      const hourOffset = i * 0.5; // 30-min intervals
      const hour = 12 + hourOffset;
      const displayHour = hour >= 24 ? hour - 24 : hour;
      const isPM = displayHour >= 12 && displayHour < 24;
      const display12h = displayHour === 0 ? 12 : displayHour === 12 ? 12 : displayHour > 12 ? displayHour - 12 : displayHour;

      // Only show labels at 12 PM, 5 PM, 12 AM
      if (hourOffset === 0) {
        labels.push('12 PM');
      } else if (hourOffset === 5) {
        labels.push('5 PM');
      } else if (hourOffset === 12) {
        labels.push('12 AM');
      } else {
        labels.push('');
      }

      // Only show data up to current position
      const pointPosition = hourOffset;
      if (pointPosition <= hoursFromNoon) {
        data.push(state.kalshi.pnl);
      } else {
        data.push(null);
      }
    }

    return { labels, data };
  }

  // 7d view: Past 7 days with current day at the end
  function generate7dData() {
    const now = new Date();
    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const labels = [];
    const data = [];

    for (let i = 6; i >= 0; i--) {
      const d = new Date(now);
      d.setDate(d.getDate() - i);
      labels.push(dayNames[d.getDay()]);
      data.push(i === 0 ? state.kalshi.pnl : 0); // Only current day has P&L
    }

    return { labels, data };
  }

  let chartData24h = generate24hData();
  let chartData7d = generate7dData();

  // ==========================================================================
  // P&L CHART
  // ==========================================================================
  const ctx = document.getElementById('pnl-chart').getContext('2d');

  const gradientPositive = ctx.createLinearGradient(0, 0, 0, 160);
  gradientPositive.addColorStop(0, 'rgba(212, 175, 55, 0.35)');
  gradientPositive.addColorStop(0.6, 'rgba(212, 175, 55, 0.12)');
  gradientPositive.addColorStop(1, 'rgba(0, 0, 0, 0)');

  const gradientNegative = ctx.createLinearGradient(0, 0, 0, 160);
  gradientNegative.addColorStop(0, 'rgba(255, 107, 107, 0.3)');
  gradientNegative.addColorStop(0.6, 'rgba(255, 107, 107, 0.12)');
  gradientNegative.addColorStop(1, 'rgba(0, 0, 0, 0)');

  const pulsingDotPlugin = {
    id: 'pulsingDot',
    afterDatasetsDraw(chart) {
      const meta = chart.getDatasetMeta(0);
      if (!meta.data.length) return;

      // Find the last non-null data point
      const data = chart.data.datasets[0].data;
      let lastValidIndex = -1;
      for (let i = data.length - 1; i >= 0; i--) {
        if (data[i] !== null) {
          lastValidIndex = i;
          break;
        }
      }
      if (lastValidIndex < 0) return;

      const lastPoint = meta.data[lastValidIndex];
      if (!lastPoint) return;
      const { x, y } = lastPoint.tooltipPosition();
      const ctx = chart.ctx;
      const now = performance.now();
      const period = 1600;
      const t = (now % period) / period; // 0..1
      const baseRadius = 5;
      const pulseRadius = baseRadius + 6 * (1 - Math.abs(0.5 - t) * 2);

      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, pulseRadius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(212, 175, 55, 0.15)';
      ctx.fill();

      ctx.beginPath();
      ctx.arc(x, y, baseRadius, 0, Math.PI * 2);
      ctx.fillStyle = '#D4AF37';
      ctx.fill();
      ctx.restore();
    }
  };

  function computeScaleBounds(series) {
    const min = Math.min(...series, 0);
    const max = Math.max(...series, 0);
    const padding = Math.max(5, (max - min) * 0.15);
    return {
      suggestedMin: min - padding,
      suggestedMax: max + padding,
    };
  }

  const pnlChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: chartData24h.labels,
      datasets: [{
        label: 'P&L',
        data: chartData24h.data,
        fill: { target: { value: 0 } },
        backgroundColor: (context) => (context.raw ?? 0) >= 0 ? gradientPositive : gradientNegative,
        borderColor: (context) => (context.raw ?? 0) >= 0 ? '#D4AF37' : '#ff6b6b',
        borderWidth: 2,
        tension: 0.4,
        pointRadius: 0,
        pointHoverRadius: 4,
        pointHoverBackgroundColor: '#FFD060',
        pointHoverBorderColor: '#D4AF37',
        spanGaps: false,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: { duration: 400 },
      interaction: {
        intersect: false,
        mode: 'index',
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(10, 10, 0, 0.9)',
          borderColor: 'rgba(212, 175, 55, 0.3)',
          borderWidth: 1,
          titleColor: '#D4AF37',
          bodyColor: '#f5f5f5',
          padding: 10,
          displayColors: false,
          callbacks: {
            label: (ctx) => `P&L: $${ctx.raw >= 0 ? '+' : ''}${ctx.raw.toFixed(2)}`
          }
        }
      },
      scales: {
        x: {
          display: true,
          grid: { display: false },
          ticks: {
            color: '#666',
            font: { size: 10, family: "-apple-system, BlinkMacSystemFont, 'SF Mono', monospace", style: 'normal' },
            maxRotation: 0,
            autoSkip: true,
            maxTicksLimit: 8,
          },
          border: { display: false },
        },
        y: {
          display: false,
          grid: {
            display: true,
            drawTicks: false,
            color: (ctx) => (ctx.tick.value === 0 ? 'rgba(212, 175, 55, 0.35)' : 'rgba(255,255,255,0.05)'),
            borderDash: (ctx) => (ctx.tick.value === 0 ? [] : [4, 4]),
          },
          beginAtZero: false,
          suggestedMin: -10,
          suggestedMax: 10,
        }
      }
    },
    plugins: [pulsingDotPlugin],
  });

  let pulseAnimationId;
  function startPulse() {
    const render = () => {
      pnlChart.draw();
      pulseAnimationId = requestAnimationFrame(render);
    };
    render();
  }
  startPulse();

  function updatePnlChart(newPnl) {
    // Update P&L in state
    state.kalshi.pnl = newPnl;

    // Regenerate chart data based on current period
    chartData24h = generate24hData();
    chartData7d = generate7dData();

    const chartData = state.currentPeriod === 'day' ? chartData24h : chartData7d;
    pnlChart.data.labels = chartData.labels;
    pnlChart.data.datasets[0].data = chartData.data;

    const validData = chartData.data.filter(v => v !== null);
    const bounds = computeScaleBounds(validData.length ? validData : [0]);
    pnlChart.options.scales.y.suggestedMin = bounds.suggestedMin;
    pnlChart.options.scales.y.suggestedMax = bounds.suggestedMax;

    pnlChart.update('none');

    // Update header value
    const chartValue = document.getElementById('chart-pnl-value');
    chartValue.textContent = `$${newPnl >= 0 ? '+' : ''}${newPnl.toFixed(2)}`;
    chartValue.className = 'chart-value ' + (newPnl > 0 ? 'pnl-positive' : newPnl < 0 ? 'pnl-negative' : '');
  }

  // ==========================================================================
  // PERIOD TOGGLE (24h / 7d)
  // ==========================================================================
  const periodBtns = document.querySelectorAll('.period-btn');

  function switchPeriod(period) {
    state.currentPeriod = period;
    periodBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.period === period));

    // Regenerate chart data
    chartData24h = generate24hData();
    chartData7d = generate7dData();

    const chartData = period === 'day' ? chartData24h : chartData7d;
    pnlChart.data.labels = chartData.labels;
    pnlChart.data.datasets[0].data = chartData.data;

    const validData = chartData.data.filter(v => v !== null);
    const bounds = computeScaleBounds(validData.length ? validData : [0]);
    pnlChart.options.scales.y.suggestedMin = bounds.suggestedMin;
    pnlChart.options.scales.y.suggestedMax = bounds.suggestedMax;

    pnlChart.update();
  }

  periodBtns.forEach(btn => {
    btn.addEventListener('click', () => switchPeriod(btn.dataset.period));
  });

  // ==========================================================================
  // TAB NAVIGATION
  // ==========================================================================
  const tabs = document.querySelectorAll('.tab');
  const sections = {
    dashboard: document.getElementById('tab-dashboard'),
    trades: document.getElementById('tab-trades'),
    config: document.getElementById('tab-config'),
    logs: document.getElementById('tab-logs'),
  };

  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      Object.values(sections).forEach(sec => sec.classList.remove('active'));
      sections[tab.dataset.tab].classList.add('active');
    });
  });

  // ==========================================================================
  // KALSHI CONTROLS
  // ==========================================================================
  const kalshiStartBtn = document.getElementById('kalshi-start-btn');
  const kalshiStatus = document.getElementById('kalshi-status');
  const kalshiBankroll = document.getElementById('kalshi-bankroll');

  kalshiStartBtn?.addEventListener('click', async () => {
    const wasRunning = state.kalshi.running;
    const endpoint = wasRunning ? '/api/stop' : '/api/start';
    
    // Show transitional state
    kalshiStartBtn.disabled = true;
    kalshiStartBtn.textContent = wasRunning ? 'Stopping...' : 'Starting...';
    kalshiStatus.textContent = wasRunning ? 'Stopping...' : 'Starting...';
    kalshiStatus.classList.remove('status-on', 'status-off');
    kalshiStatus.classList.add('status-pending');
    
    try {
      const res = await fetch(endpoint, { method: 'POST' });
      const data = await res.json();
      state.kalshi.running = data.running;
      if (data.stats) {
        state.stats = data.stats;
        state.kalshi.bankroll = data.stats.bankroll;
        state.kalshi.pnl = data.stats.total_pnl;
      }
      refreshKalshiStatus(wasRunning);
      updateStats(state.stats);
    } catch (err) {
      // Revert on error
      state.kalshi.running = wasRunning;
      refreshKalshiStatus();
    } finally {
      kalshiStartBtn.disabled = false;
    }
  });

  function refreshKalshiStatus(wasRunning = null) {
    kalshiStatus.textContent = state.kalshi.running ? "PRINTIN'" : 'Inactive';
    kalshiStatus.classList.remove('status-on', 'status-off', 'status-pending');
    kalshiStatus.classList.add(state.kalshi.running ? 'status-on' : 'status-off');
    kalshiStartBtn.textContent = state.kalshi.running ? 'Stop' : 'Start';
    kalshiStartBtn.classList.toggle('engine-active', state.kalshi.running);
    
    // Toggle gold tracer effect based on engine running state
    const tickerCard = document.getElementById('ticker-kalshi');
    tickerCard.classList.toggle('engine-running', state.kalshi.running);
    
    // Apply flicker effects on state change
    if (wasRunning !== null && wasRunning !== state.kalshi.running) {
      kalshiStartBtn.classList.remove('flicker-on', 'flicker-off');
      if (state.kalshi.running) {
        // Turned on - flicker on
        kalshiStartBtn.classList.add('flicker-on');
      } else {
        // Turned off - flicker off
        kalshiStartBtn.classList.add('flicker-off');
      }
      // Remove the class after animation completes
      setTimeout(() => {
        kalshiStartBtn.classList.remove('flicker-on', 'flicker-off');
      }, 600);
    }
  }

  // ==========================================================================
  // UPLINK BUTTON
  // ==========================================================================
  const uplinkBtn = document.getElementById('kalshi-uplink-btn');
  const uplinkStatusPill = document.getElementById('uplink-status-pill');
  const uplinkErrorMsg = document.getElementById('uplink-error-msg');

  function setUplinkBtnState(state) {
    if (!uplinkBtn) return;
    uplinkBtn.classList.remove('checking', 'connected', 'disconnected');
    if (state) uplinkBtn.classList.add(state);
  }

  uplinkBtn?.addEventListener('click', async () => {
    // Set checking state
    uplinkStatusPill.className = 'ticker-tag status-pill checking';
    uplinkStatusPill.textContent = 'Checking...';
    uplinkErrorMsg.textContent = '';
    setUplinkBtnState('checking');
    uplinkBtn.disabled = true;

    try {
      const res = await fetch('/api/uplink', { method: 'POST' });
      const data = await res.json();

      if (data.connected) {
        uplinkStatusPill.className = 'ticker-tag status-pill connected';
        uplinkStatusPill.textContent = 'Connected';
        uplinkErrorMsg.textContent = '';
        setUplinkBtnState('connected');
        // Add green border effect for uplink connected
        document.getElementById('ticker-kalshi').classList.add('uplink-connected');
        // Update balance if returned
        if (data.balance !== undefined) {
          state.kalshi.bankroll = data.balance;
          kalshiBankroll.textContent = `$${data.balance.toFixed(2)}`;
        }
        // Update P&L chart with real data
        if (data.pnl !== undefined) {
          updatePnlChart(data.pnl);
        }
      } else {
        uplinkStatusPill.className = 'ticker-tag status-pill disconnected';
        uplinkStatusPill.textContent = 'Disconnected';
        uplinkErrorMsg.textContent = data.error || 'Connection failed';
        setUplinkBtnState('disconnected');
        // Remove green border effect
        document.getElementById('ticker-kalshi').classList.remove('uplink-connected');
      }
    } catch (err) {
      uplinkStatusPill.className = 'ticker-tag status-pill disconnected';
      uplinkStatusPill.textContent = 'Error';
      uplinkErrorMsg.textContent = err.message || 'Network error';
      setUplinkBtnState('disconnected');
      // Remove green border effect
      document.getElementById('ticker-kalshi').classList.remove('uplink-connected');
    } finally {
      uplinkBtn.disabled = false;
    }
  });

  // ==========================================================================
  // STATS UPDATER
  // ==========================================================================
  function updateStats(stats) {
    state.stats = stats;
    state.kalshi.bankroll = stats.bankroll;
    state.kalshi.pnl = stats.total_pnl;

    // Update dashboard stats cards
    const rrEl = document.getElementById('stat-rr');
    rrEl.textContent = stats.trades > 0 ? stats.avg_rr.toFixed(2) : '--';
    document.getElementById('stat-trades').textContent = stats.trades;
    document.getElementById('stat-winrate').textContent = stats.trades > 0 ? `${stats.win_rate.toFixed(1)}%` : '--%';
    document.getElementById('stat-wins').textContent = stats.wins;
    document.getElementById('stat-losses').textContent = stats.losses;

    // Update Kalshi ticker
    kalshiBankroll.textContent = `$${state.kalshi.bankroll.toFixed(2)}`;

    // Update P&L chart
    updatePnlChart(stats.total_pnl);
  }

  // ==========================================================================
  // CONFIG FORM
  // ==========================================================================
  const configForm = document.getElementById('config-form');
  const resetBtn = document.getElementById('reset-config');

  configForm?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const formData = new FormData(configForm);
    const payload = {};
    formData.forEach((v, k) => payload[k] = v);
    payload.kelly_multiplier = parseFloat(payload.kelly_multiplier);
    payload.target_buy_ev = parseFloat(payload.target_buy_ev);
    payload.target_sell_ev = parseFloat(payload.target_sell_ev);
    payload.max_percentage_bet = parseFloat(payload.max_percentage_bet);
    payload.max_dollar_bet = parseFloat(payload.max_dollar_bet);
    payload.min_true_prob = parseFloat(payload.min_true_prob);
    payload.max_true_prob = parseFloat(payload.max_true_prob);
    payload.trading_start = parseInt(payload.trading_start, 10);
    payload.trading_end = parseInt(payload.trading_end, 10);
    payload.sports = (payload.sports || '').split(',').map(s => s.trim()).filter(Boolean);
    payload.boltodds_api_key = payload.boltodds_api_key || '';

    const res = await fetch('/api/config', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    const data = await res.json();
    state.config = data.config;
    appendLog('[Config] Settings saved successfully');
  });

  resetBtn?.addEventListener('click', () => {
    configForm.reset();
    // Reset sport chips to default
    document.querySelectorAll('.sport-chip').forEach(chip => {
      const defaultSports = ['NBA', 'NFL', 'NHL'];
      chip.classList.toggle('active', defaultSports.includes(chip.dataset.sport));
    });
    updateSportsInput();
  });

  // Sport Chips Handler
  const sportChips = document.querySelectorAll('.sport-chip');
  const sportsInput = document.getElementById('sports-input');

  function updateSportsInput() {
    const activeSports = Array.from(document.querySelectorAll('.sport-chip.active'))
      .map(chip => chip.dataset.sport);
    sportsInput.value = activeSports.join(',');
  }

  sportChips.forEach(chip => {
    chip.addEventListener('click', () => {
      chip.classList.toggle('active');
      updateSportsInput();
    });
  });

  // ==========================================================================
  // SSE STREAMS
  // ==========================================================================
  const logArea = document.getElementById('log-area');
  const oppBody = document.getElementById('opportunities-body');
  const tradesBody = document.getElementById('trades-body');
  const oppSearch = document.getElementById('opp-search');
  const oppSort = document.getElementById('opp-sort');
  const oppSportFilter = document.getElementById('opp-sport-filter');

  function appendLog(line) {
    const div = document.createElement('div');
    div.textContent = line;
    logArea.appendChild(div);
    logArea.scrollTop = logArea.scrollHeight;
  }

  document.getElementById('clear-logs')?.addEventListener('click', () => {
    logArea.innerHTML = '';
  });

  function renderOpportunities() {
    const searchTerm = (oppSearch?.value || '').toLowerCase();
    const sportFilter = (oppSportFilter?.value || '').toLowerCase();
    const sortKey = oppSort?.value || 'timestamp';

    const filtered = state.opportunities
      .filter((opp) => {
        const matchesSearch = opp.matchup.toLowerCase().includes(searchTerm) || opp.team.toLowerCase().includes(searchTerm);
        const matchesSport = !sportFilter || (opp.sport || '').toLowerCase() === sportFilter;
        return matchesSearch && matchesSport;
      })
      .sort((a, b) => {
        if (sortKey === 'edge') return b.edge - a.edge;
        if (sortKey === 'stake') return (b.kelly_stake || 0) - (a.kelly_stake || 0);
        return (b.timestamp || 0) - (a.timestamp || 0);
      });

    oppBody.innerHTML = '';
    if (!filtered.length) {
      oppBody.innerHTML = '<tr><td colspan="7" class="muted">No opportunities match the filters.</td></tr>';
      return;
    }

    filtered.forEach((opp) => {
      const stake = Number(opp.kelly_stake ?? 0);
      const trueProb = Number(opp.true_prob ?? 0);
      const marketProb = Number(opp.market_prob ?? 0);
      const edge = Number(opp.edge ?? 0);
      const tr = document.createElement('tr');
      const ts = opp.timestamp ? new Date(opp.timestamp * 1000).toLocaleTimeString() : '--';
      tr.innerHTML = `
        <td>${opp.matchup}</td>
        <td>${opp.team}</td>
        <td>${(trueProb * 100).toFixed(1)}%</td>
        <td>${(marketProb * 100).toFixed(1)}%</td>
        <td>${edge.toFixed(2)}%</td>
        <td>$${stake.toFixed(2)}</td>
        <td>${ts}</td>
      `;
      oppBody.appendChild(tr);
    });
  }

  oppSearch?.addEventListener('input', renderOpportunities);
  oppSort?.addEventListener('change', renderOpportunities);
  oppSportFilter?.addEventListener('change', renderOpportunities);

  function addOpportunity(opp) {
    state.oppCount += 1;
    state.opportunities.unshift(opp);
    if (state.opportunities.length > 200) {
      state.opportunities.pop();
    }
    renderOpportunities();
  }

  function addTrade(trade) {
    const tr = document.createElement('tr');
    tr.className = `trade-row ${trade.result === 'WIN' ? 'win' : 'loss'}`;
    const pnlClass = trade.pnl > 0 ? 'pnl-positive' : trade.pnl < 0 ? 'pnl-negative' : '';
    const badgeClass = trade.result === 'WIN' ? 'badge-win' : trade.result === 'LOSS' ? 'badge-loss' : 'badge-pending';
    tr.innerHTML = `
      <td>${new Date(trade.timestamp * 1000).toLocaleTimeString()}</td>
      <td>${trade.matchup}</td>
      <td>${trade.team}</td>
      <td>${(trade.entry_price * 100).toFixed(1)}%</td>
      <td>$${trade.stake.toFixed(2)}</td>
      <td>${trade.edge.toFixed(2)}%</td>
      <td><span class="badge ${badgeClass}">${trade.result}</span></td>
      <td class="${pnlClass}">${trade.pnl >= 0 ? '+' : ''}${trade.pnl.toFixed(2)}</td>
    `;
    if (tradesBody.children.length === 1 && tradesBody.children[0].querySelector('.muted')) {
      tradesBody.innerHTML = '';
    }
    tradesBody.prepend(tr);
    while (tradesBody.children.length > 50) {
      tradesBody.removeChild(tradesBody.lastChild);
    }
  }

  // Log stream
  const logStream = new EventSource('/stream/logs');
  logStream.onmessage = (event) => {
    const data = JSON.parse(event.data);
    appendLog(data.log);
  };

  // Opportunity stream
  const oppStream = new EventSource('/stream/opportunities');
  oppStream.onmessage = (event) => {
    const data = JSON.parse(event.data);
    addOpportunity(data);
  };

  // Trades stream
  const tradeStream = new EventSource('/stream/trades');
  tradeStream.onmessage = (event) => {
    const trade = JSON.parse(event.data);
    addTrade(trade);
    fetch('/api/stats')
      .then(r => r.json())
      .then(stats => updateStats(stats));
  };

  // Periodic stats refresh for live Kalshi balance/P&L
  setInterval(() => {
    fetch('/api/stats')
      .then(r => r.json())
      .then(stats => updateStats(stats))
      .catch(() => { });
  }, 10000);

  // Initial render
  refreshKalshiStatus();
  updateStats(state.stats);
  renderOpportunities();
</script>
{% endblock %}